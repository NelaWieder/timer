<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0a0118">
    <title>Mars Timer | Multiplayer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Exo+2:wght@300;400;500;600;700;800&subset=latin-ext&display=swap" rel="stylesheet">
</head>
<body>
    <div class="galaxy-bg"></div>
    <div class="stars"></div>
    <div class="bg-overlay"></div>
    
    <svg class="svg-defs">
        <defs>
            <linearGradient id="timerGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#a855f7"/>
                <stop offset="100%" style="stop-color:#ec4899"/>
            </linearGradient>
        </defs>
    </svg>
    
    <div class="connection-status" id="connectionStatus">‚ö† Brak po≈ÇƒÖczenia...</div>
    
    <!-- LOBBY SCREEN -->
    <div class="screen lobby-screen active" id="lobbyScreen">
        <div class="lobby-logo">
            <h1>Mars Timer</h1>
            <p>Multiplayer</p>
        </div>
        <div class="lobby-actions">
            <button class="lobby-btn primary" id="createRoomBtn">Stw√≥rz pok√≥j</button>
            <div class="lobby-divider">lub</div>
            <button class="lobby-btn secondary" id="showJoinBtn">Do≈ÇƒÖcz do gry</button>
        </div>
        <div class="join-form" id="joinForm">
            <input type="text" class="join-input" id="joinCodeInput" placeholder="KOD" maxlength="4" autocomplete="off">
            <button class="lobby-btn primary" id="joinRoomBtn">Do≈ÇƒÖcz</button>
        </div>
    </div>
    
    <!-- NAME MODAL -->
    <div class="name-modal" id="nameModal">
        <div class="name-modal-content">
            <h2>Jak masz na imiƒô?</h2>
            <p>Wybierz sw√≥j kolor</p>
            <input type="text" class="name-input" id="playerNameInput" placeholder="Twoje imiƒô" maxlength="12">
            <div class="color-picker" id="colorPicker">
                <div class="color-option blue selected" data-color="blue"></div>
                <div class="color-option red" data-color="red"></div>
                <div class="color-option green" data-color="green"></div>
                <div class="color-option yellow" data-color="yellow"></div>
                <div class="color-option black" data-color="black"></div>
            </div>
            <button class="lobby-btn primary" id="confirmNameBtn">Potwierd≈∫</button>
        </div>
    </div>
    
    <!-- WAITING ROOM -->
    <div class="screen waiting-screen" id="waitingScreen">
        <div class="room-header">
            <div class="room-code-label">Kod pokoju</div>
            <div class="room-code" id="roomCodeDisplay">----</div>
            <div class="qr-container" id="qrContainer"></div>
        </div>
        <div class="time-setting-mini" id="timeSettingMini" style="display:none;">
            <div class="time-label-mini">Czas tury:</div>
            <button class="time-btn-mini" id="timeDownMini">‚àí</button>
            <div class="time-display-mini"><span id="timeValueMini">45</span>s</div>
            <button class="time-btn-mini" id="timeUpMini">+</button>
        </div>
        <div class="players-waiting">
            <div class="players-waiting-title">Gracze w pokoju</div>
            <div id="waitingPlayersList"></div>
        </div>
        <div class="waiting-actions">
            <button class="start-game-btn" id="startGameBtn" disabled>Czekam na graczy...</button>
            <button class="leave-btn" id="leaveRoomBtn">Opu≈õƒá pok√≥j</button>
        </div>
    </div>
    
    <!-- GAME SCREEN -->
    <div class="screen game-screen" id="gameScreen">
        <div class="generation-bar">
            <div class="generation-info">
                <span class="generation-label">Pokolenie</span>
                <span class="generation-number" id="genNumber">1</span>
            </div>
            <div class="game-timer" id="gameTimer">0:00</div>
            <button class="menu-btn" id="menuBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="players-strip" id="playersStrip"></div>
        <div class="timer-area">
            <div class="current-player-name" id="currentPlayerName">---</div>
            <div class="current-player-label" id="currentPlayerLabel">Tura gracza</div>
            <div class="timer-display">
                <div class="mars-planet">
                    <img src="https://upload.wikimedia.org/wikipedia/commons/0/02/OSIRIS_Mars_true_color.jpg" alt="Mars">
                </div>
                <div class="timer-overlay"></div>
                <div class="timer-ring">
                    <svg viewBox="0 0 280 280">
                        <circle class="timer-ring-bg" cx="140" cy="140" r="130"/>
                        <circle class="timer-ring-progress" id="timerProgress" cx="140" cy="140" r="130"/>
                    </svg>
                </div>
                <div class="timer-text" id="timerText">0:45</div>
            </div>
        </div>
        <div class="action-area">
            <button class="pass-btn" id="passBtn">PASS</button>
            <div class="secondary-actions">
                <button class="action-btn pass-gen" id="passGenBtn"><div class="progress-fill"></div><span>Pass Gen</span></button>
                <button class="action-btn admin-time host-only" id="adminTimeBtn">Admin Time</button>
            </div>
        </div>
        <div class="admin-overlay" id="adminOverlay">
            <svg class="admin-overlay-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
            <h2 id="overlayTitle">Admin Time</h2>
            <p id="overlayText">Gra wstrzymana</p>
            <button class="resume-btn host-only" id="resumeBtn">Wzn√≥w grƒô</button>
        </div>
    </div>
    
    <!-- HOST PANEL -->
    <div class="host-panel-backdrop" id="hostPanelBackdrop"></div>
    <div class="host-panel" id="hostPanel">
        <div class="host-panel-header">
            <h2>Panel</h2>
            <button class="close-panel-btn" id="closePanelBtn">‚úï</button>
        </div>
        <div class="host-panel-section" id="hostOnlySection" style="display:none;">
            <div class="host-panel-section-title">Kontrola gry (Host)</div>
            <button class="host-action-btn next-gen-btn" id="nextGenBtn" style="display:none;">üöÄ Nastƒôpne Pokolenie</button>
            <button class="host-action-btn" id="forceNextBtn">‚è≠ Nastƒôpna tura</button>
            <button class="host-action-btn" id="hostAdminBtn">‚è∏ Admin Time</button>
        </div>
        <div class="host-panel-section" id="hostSoundSection" style="display:none;">
            <div class="host-panel-section-title">D≈∫wiƒôk</div>
            <button class="host-action-btn" id="muteBtn">üîä Wycisz d≈∫wiƒôki</button>
        </div>
        <div class="host-panel-section">
            <div class="host-panel-section-title">Pok√≥j</div>
            <button class="host-action-btn danger" id="leaveGameBtn">üö™ Opu≈õƒá grƒô</button>
        </div>
        <div class="room-info-small">Kod pokoju: <span id="roomCodeSmall">----</span></div>
    </div>

    <!-- QRCode Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    
    <!-- Firebase -->
    <script type="module">
        // =============================================
        // FIREBASE CONFIG
        // =============================================
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { 
            getDatabase, ref, set, get, onValue, off, update, remove, onDisconnect, serverTimestamp 
        } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyCQwMpiRgAIXs7g6el_35HepBqOcm6gQVU",
            authDomain: "tm-timer-nw.firebaseapp.com",
            databaseURL: "https://tm-timer-nw-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "tm-timer-nw",
            storageBucket: "tm-timer-nw.firebasestorage.app",
            messagingSenderId: "425133932279",
            appId: "1:425133932279:web:c631018437f5dcdf115df2"
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        
        // =============================================
        // CONSTANTS
        // =============================================
        const COLORS = ['blue', 'red', 'green', 'yellow', 'black'];
        const COLOR_HEX = { red: '#f43f5e', blue: '#3b82f6', green: '#22c55e', yellow: '#facc15', black: '#6b7280' };
        
        // Polish ordinal numbers for generation announcement
        const POLISH_ORDINALS = {
            1: 'pierwsze', 2: 'drugie', 3: 'trzecie', 4: 'czwarte', 5: 'piƒÖte',
            6: 'sz√≥ste', 7: 'si√≥dme', 8: '√≥sme', 9: 'dziewiƒÖte', 10: 'dziesiƒÖte',
            11: 'jedenaste', 12: 'dwunaste', 13: 'trzynaste', 14: 'czternaste', 15: 'piƒôtnaste',
            16: 'szesnaste', 17: 'siedemnaste', 18: 'osiemnaste', 19: 'dziewiƒôtnaste', 20: 'dwudzieste'
        };
        
        // =============================================
        // STATE
        // =============================================
        let state = {
            roomId: null,
            playerId: null,
            playerName: '',
            playerColor: 'blue',
            isHost: false,
            isMuted: false,
            turnDuration: 45,
            players: {},
            gameState: null,
            localTimerInterval: null,
            gameTimerInterval: null,
            audioContext: null,
            holdTimeout: null,
            holdProgress: 0,
            lastWarningTime: -1,
            warningPlayed: false,
            timeUpPlayed: false
        };
        
        let unsubscribers = [];
        
        // =============================================
        // TTS (TEXT-TO-SPEECH) MODULE - CROSS-PLATFORM
        // =============================================
        const TTS = {
            isUnlocked: false,
            selectedVoice: null,
            voicesLoaded: false,
            speakQueue: [],
            isSpeaking: false,
            
            // Detect platform
            getPlatform() {
                const ua = navigator.userAgent;
                if (/iPad|iPhone|iPod/.test(ua) && !window.MSStream) return 'ios';
                if (/Android/.test(ua)) return 'android';
                return 'desktop';
            },
            
            // Initialize TTS - call after user interaction
            init() {
                if (!('speechSynthesis' in window)) {
                    console.warn('Speech Synthesis not supported');
                    return false;
                }
                
                // Force load voices
                this.loadVoices();
                
                // iOS/Safari: voices load asynchronously
                if (speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = () => this.loadVoices();
                }
                
                return true;
            },
            
            // Load and select best voice
            loadVoices() {
                const voices = speechSynthesis.getVoices();
                if (voices.length === 0) return;
                
                this.voicesLoaded = true;
                const platform = this.getPlatform();
                
                // Try to find Polish voice
                const plVoices = voices.filter(v => v.lang.startsWith('pl'));
                
                if (plVoices.length > 0) {
                    // Prefer Google/native voices
                    const preferredVoice = plVoices.find(v => 
                        v.name.includes('Google') || 
                        v.name.includes('Microsoft') ||
                        v.name.includes('Zosia') ||
                        v.localService === false
                    ) || plVoices[0];
                    
                    this.selectedVoice = preferredVoice;
                    console.log('TTS: Selected voice:', preferredVoice.name);
                } else {
                    // No Polish voice found - will use lang='pl-PL' fallback
                    this.selectedVoice = null;
                    console.log('TTS: No Polish voice found, using lang fallback');
                }
            },
            
            // Unlock TTS (required for iOS/Safari)
            unlock() {
                if (this.isUnlocked) return Promise.resolve(true);
                
                return new Promise((resolve) => {
                    // Create silent utterance to unlock
                    const utterance = new SpeechSynthesisUtterance('');
                    utterance.volume = 0;
                    utterance.onend = () => {
                        this.isUnlocked = true;
                        console.log('TTS: Unlocked successfully');
                        resolve(true);
                    };
                    utterance.onerror = () => {
                        // Try alternative unlock
                        speechSynthesis.cancel();
                        this.isUnlocked = true;
                        resolve(true);
                    };
                    
                    speechSynthesis.speak(utterance);
                    
                    // Timeout fallback
                    setTimeout(() => {
                        this.isUnlocked = true;
                        resolve(true);
                    }, 500);
                });
            },
            
            // Main speak function
            speak(text, priority = false) {
                if (!state.isHost || state.isMuted || !('speechSynthesis' in window)) return;
                
                if (priority) {
                    // Cancel current speech for priority messages
                    speechSynthesis.cancel();
                    this.speakQueue = [];
                }
                
                // Add to queue
                this.speakQueue.push(text);
                this.processQueue();
            },
            
            // Process speech queue
            processQueue() {
                if (this.isSpeaking || this.speakQueue.length === 0) return;
                
                const text = this.speakQueue.shift();
                this.isSpeaking = true;
                
                // Cancel any pending speech
                speechSynthesis.cancel();
                
                // Small delay for iOS stability
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'pl-PL';
                    utterance.rate = 1.0;
                    utterance.pitch = 0.9;
                    utterance.volume = 1.0;
                    
                    // Set voice if available
                    if (this.selectedVoice) {
                        utterance.voice = this.selectedVoice;
                    }
                    
                    utterance.onend = () => {
                        this.isSpeaking = false;
                        // Process next in queue
                        setTimeout(() => this.processQueue(), 100);
                    };
                    
                    utterance.onerror = (e) => {
                        console.warn('TTS error:', e.error);
                        this.isSpeaking = false;
                        setTimeout(() => this.processQueue(), 100);
                    };
                    
                    // Workaround for Chrome bug where speech stops after ~15s
                    const platform = this.getPlatform();
                    if (platform === 'desktop') {
                        // Resume if paused
                        if (speechSynthesis.paused) {
                            speechSynthesis.resume();
                        }
                    }
                    
                    speechSynthesis.speak(utterance);
                }, 50);
            },
            
            // Stop all speech
            stop() {
                speechSynthesis.cancel();
                this.speakQueue = [];
                this.isSpeaking = false;
            }
        };
        
        // =============================================
        // DOM ELEMENTS
        // =============================================
        const $ = id => document.getElementById(id);
        const el = {
            connectionStatus: $('connectionStatus'),
            lobbyScreen: $('lobbyScreen'),
            waitingScreen: $('waitingScreen'),
            gameScreen: $('gameScreen'),
            nameModal: $('nameModal'),
            createRoomBtn: $('createRoomBtn'),
            showJoinBtn: $('showJoinBtn'),
            joinForm: $('joinForm'),
            joinCodeInput: $('joinCodeInput'),
            joinRoomBtn: $('joinRoomBtn'),
            playerNameInput: $('playerNameInput'),
            colorPicker: $('colorPicker'),
            confirmNameBtn: $('confirmNameBtn'),
            roomCodeDisplay: $('roomCodeDisplay'),
            qrContainer: $('qrContainer'),
            timeSettingMini: $('timeSettingMini'),
            timeValueMini: $('timeValueMini'),
            timeUpMini: $('timeUpMini'),
            timeDownMini: $('timeDownMini'),
            waitingPlayersList: $('waitingPlayersList'),
            startGameBtn: $('startGameBtn'),
            leaveRoomBtn: $('leaveRoomBtn'),
            genNumber: $('genNumber'),
            gameTimer: $('gameTimer'),
            playersStrip: $('playersStrip'),
            currentPlayerName: $('currentPlayerName'),
            currentPlayerLabel: $('currentPlayerLabel'),
            timerText: $('timerText'),
            timerProgress: $('timerProgress'),
            passBtn: $('passBtn'),
            passGenBtn: $('passGenBtn'),
            adminTimeBtn: $('adminTimeBtn'),
            adminOverlay: $('adminOverlay'),
            overlayTitle: $('overlayTitle'),
            overlayText: $('overlayText'),
            resumeBtn: $('resumeBtn'),
            menuBtn: $('menuBtn'),
            hostPanel: $('hostPanel'),
            hostPanelBackdrop: $('hostPanelBackdrop'),
            closePanelBtn: $('closePanelBtn'),
            hostOnlySection: $('hostOnlySection'),
            hostSoundSection: $('hostSoundSection'),
            nextGenBtn: $('nextGenBtn'),
            forceNextBtn: $('forceNextBtn'),
            hostAdminBtn: $('hostAdminBtn'),
            muteBtn: $('muteBtn'),
            leaveGameBtn: $('leaveGameBtn'),
            roomCodeSmall: $('roomCodeSmall')
        };
        
        // =============================================
        // UTILITY FUNCTIONS
        // =============================================
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            let code = '';
            for (let i = 0; i < 4; i++) code += chars[Math.floor(Math.random() * chars.length)];
            return code;
        }
        
        function generatePlayerId() {
            return 'p_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }
        
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            $(screenId).classList.add('active');
        }
        
        function formatTime(seconds) {
            const abs = Math.abs(Math.ceil(seconds));
            const mins = Math.floor(abs / 60);
            const secs = abs % 60;
            const sign = seconds < 0 ? '-' : '';
            return mins > 0 ? `${sign}${mins}:${secs.toString().padStart(2, '0')}` : `${sign}${secs}`;
        }
        
        function formatGameTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hrs > 0) return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Get Polish ordinal for generation number
        function getPolishOrdinal(num) {
            if (POLISH_ORDINALS[num]) return POLISH_ORDINALS[num];
            // For numbers > 20, just say the number
            return num.toString();
        }
        
        // =============================================
        // AUDIO (HOST ONLY!) - SOUND EFFECTS
        // =============================================
        function initAudio() {
            if (!state.audioContext) {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (state.audioContext.state === 'suspended') {
                state.audioContext.resume();
            }
            
            // Initialize TTS
            TTS.init();
            TTS.unlock();
        }
        
        function playBeep(freq = 800, dur = 150, type = 'sine', volume = 0.3) {
            if (!state.isHost || !state.audioContext || state.isMuted) return;
            
            try {
                // Resume context if suspended
                if (state.audioContext.state === 'suspended') {
                    state.audioContext.resume();
                }
                
                const osc = state.audioContext.createOscillator();
                const gain = state.audioContext.createGain();
                osc.connect(gain);
                gain.connect(state.audioContext.destination);
                osc.frequency.value = freq;
                osc.type = type;
                gain.gain.setValueAtTime(volume, state.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + dur / 1000);
                osc.start(state.audioContext.currentTime);
                osc.stop(state.audioContext.currentTime + dur / 1000);
            } catch (e) {
                console.warn('Audio playback error:', e);
            }
        }
        
        // Sound: Turn start (when switching to new player)
        function playTurnStart() {
            playBeep(600, 100);
            setTimeout(() => playBeep(800, 150), 120);
        }
        
        // Sound: 5-second warning (short beep)
        function playWarning() {
            playBeep(880, 150, 'sine', 0.4);
        }
        
        // Sound: Time's up (loud sound at 00:00)
        function playTimeUp() {
            playBeep(300, 300, 'sawtooth', 0.5);
            setTimeout(() => playBeep(250, 400, 'sawtooth', 0.5), 350);
        }
        
        // TTS wrapper function
        function speak(text, priority = false) {
            TTS.speak(text, priority);
        }
        
        // =============================================
        // WAKE LOCK API
        // =============================================
        let wakeLock = null;
        
        async function requestWakeLock() {
            if (!('wakeLock' in navigator)) return;
            
            // Release existing lock first
            if (wakeLock !== null) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                } catch (e) {}
            }
            
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake Lock: Acquired');
                
                wakeLock.addEventListener('release', () => {
                    console.log('Wake Lock: Released');
                    wakeLock = null;
                });
            } catch (err) {
                console.log('Wake Lock error:', err.name, err.message);
            }
        }
        
        // Re-acquire wake lock when page becomes visible again
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
                // Re-acquire wake lock
                await requestWakeLock();
                
                // Resume audio context if needed
                if (state.audioContext && state.audioContext.state === 'suspended') {
                    state.audioContext.resume();
                }
            }
        });
        
        // =============================================
        // LOCAL STORAGE (Auto-Reconnect)
        // =============================================
        function saveSession() {
            localStorage.setItem('marsTimer_session', JSON.stringify({
                roomId: state.roomId,
                playerId: state.playerId,
                playerName: state.playerName,
                playerColor: state.playerColor,
                isHost: state.isHost
            }));
        }
        
        function loadSession() {
            try {
                const saved = localStorage.getItem('marsTimer_session');
                if (saved) return JSON.parse(saved);
            } catch(e) {}
            return null;
        }
        
        function clearSession() {
            localStorage.removeItem('marsTimer_session');
        }
        
        // =============================================
        // QR CODE
        // =============================================
        function generateQR(code) {
            el.qrContainer.innerHTML = '';
            const url = window.location.href.split('?')[0] + '?room=' + code;
            if (typeof QRCode !== 'undefined') {
                QRCode.toCanvas(url, { width: 120, margin: 1 }, (err, canvas) => {
                    if (!err) el.qrContainer.appendChild(canvas);
                });
            }
        }
        
        // =============================================
        // FIREBASE: ROOM MANAGEMENT
        // =============================================
        async function createRoom() {
            const roomCode = generateRoomCode();
            state.roomId = roomCode;
            state.playerId = generatePlayerId();
            state.isHost = true;
            
            const roomRef = ref(db, `rooms/${roomCode}`);
            await set(roomRef, {
                host: state.playerId,
                state: 'waiting',
                turnDuration: state.turnDuration,
                createdAt: serverTimestamp()
            });
            
            showNameModal();
        }
        
        async function joinRoom(code) {
            const roomCode = code.toUpperCase();
            const roomRef = ref(db, `rooms/${roomCode}`);
            const snapshot = await get(roomRef);
            
            if (!snapshot.exists()) {
                alert('Nie znaleziono pokoju o tym kodzie!');
                return false;
            }
            
            const roomData = snapshot.val();
            if (roomData.state !== 'waiting') {
                alert('Gra ju≈º siƒô rozpoczƒô≈Ça!');
                return false;
            }
            
            state.roomId = roomCode;
            state.playerId = generatePlayerId();
            state.isHost = false;
            state.turnDuration = roomData.turnDuration || 45;
            
            showNameModal();
            return true;
        }
        
        function showNameModal() {
            el.nameModal.classList.add('active');
            el.playerNameInput.focus();
        }
        
        async function confirmPlayer() {
            const name = el.playerNameInput.value.trim();
            if (!name) {
                alert('Wpisz swoje imiƒô!');
                return;
            }
            
            state.playerName = name;
            
            // Count existing players for order
            const playersRef = ref(db, `rooms/${state.roomId}/players`);
            const snapshot = await get(playersRef);
            const existingPlayers = snapshot.exists() ? Object.keys(snapshot.val()).length : 0;
            
            // Add player to room
            const playerRef = ref(db, `rooms/${state.roomId}/players/${state.playerId}`);
            await set(playerRef, {
                name: state.playerName,
                color: state.playerColor,
                passedGen: false,
                online: true,
                order: existingPlayers,
                isHost: state.isHost
            });
            
            // Set up disconnect handler
            onDisconnect(playerRef).update({ online: false });
            
            el.nameModal.classList.remove('active');
            saveSession();
            
            if (state.isHost) {
                initAudio();
                document.body.classList.add('is-host');
                el.hostOnlySection.style.display = 'block';
                el.hostSoundSection.style.display = 'block';
                el.timeSettingMini.style.display = 'flex';
            }
            
            enterWaitingRoom();
        }
        
        function enterWaitingRoom() {
            showScreen('waitingScreen');
            el.roomCodeDisplay.textContent = state.roomId;
            el.roomCodeSmall.textContent = state.roomId;
            el.timeValueMini.textContent = state.turnDuration;
            generateQR(state.roomId);
            
            // Listen for room data
            const roomRef = ref(db, `rooms/${state.roomId}`);
            const unsubRoom = onValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    alert('Pok√≥j zosta≈Ç zamkniƒôty');
                    leaveRoom();
                    return;
                }
                
                const data = snapshot.val();
                state.players = data.players || {};
                state.turnDuration = data.turnDuration || 45;
                el.timeValueMini.textContent = state.turnDuration;
                
                updateWaitingPlayersList();
                updateStartButton();
                
                // Check if game started
                if (data.state === 'playing') {
                    startGameListener();
                }
            });
            unsubscribers.push(() => off(roomRef));
            
            if (state.isHost) {
                el.startGameBtn.textContent = 'Rozpocznij grƒô';
            } else {
                el.startGameBtn.textContent = 'Czekam na hosta...';
                el.startGameBtn.disabled = true;
            }
        }
        
        function updateWaitingPlayersList() {
            const players = Object.entries(state.players).sort((a, b) => a[1].order - b[1].order);
            el.waitingPlayersList.innerHTML = players.map(([id, p]) => `
                <div class="player-waiting-item ${!p.online ? 'offline' : ''}">
                    <div class="player-waiting-color" style="background: ${COLOR_HEX[p.color]}"></div>
                    <div class="player-waiting-name">${p.name}</div>
                    ${p.isHost ? '<div class="player-waiting-host">Host</div>' : ''}
                    ${id === state.playerId ? '<div class="player-waiting-you">Ty</div>' : ''}
                </div>
            `).join('');
        }
        
        function updateStartButton() {
            if (!state.isHost) return;
            const onlinePlayers = Object.values(state.players).filter(p => p.online).length;
            el.startGameBtn.disabled = onlinePlayers < 2;
            el.startGameBtn.textContent = onlinePlayers < 2 ? 'Minimum 2 graczy' : 'Rozpocznij grƒô';
        }
        
        async function updateTurnDuration(delta) {
            if (!state.isHost) return;
            state.turnDuration = Math.max(15, Math.min(180, state.turnDuration + delta));
            await update(ref(db, `rooms/${state.roomId}`), { turnDuration: state.turnDuration });
        }
        
        async function startGame() {
            if (!state.isHost) return;
            
            const players = Object.entries(state.players)
                .filter(([id, p]) => p.online)
                .sort((a, b) => a[1].order - b[1].order);
            const playerIds = players.map(([id]) => id);
            
            await update(ref(db, `rooms/${state.roomId}`), {
                state: 'playing',
                generation: 1,
                currentPlayerIndex: 0,
                startPlayerIndex: 0,
                playerOrder: playerIds,
                turnStartTime: Date.now(),
                turnDuration: state.turnDuration,
                isPaused: false,
                gameStartTime: Date.now()
            });
            
            // Announce first player
            const firstPlayer = players[0][1];
            playTurnStart();
            speak(firstPlayer.name);
        }
        
        function startGameListener() {
            showScreen('gameScreen');
            requestWakeLock();
            
            // Clean up any existing intervals
            if (state.localTimerInterval) clearInterval(state.localTimerInterval);
            if (state.gameTimerInterval) clearInterval(state.gameTimerInterval);
            
            // Reset warning flags
            state.warningPlayed = false;
            state.timeUpPlayed = false;
            state.lastWarningTime = -1;
            
            // Listen for game state changes
            const roomRef = ref(db, `rooms/${state.roomId}`);
            const unsubGame = onValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    leaveRoom();
                    return;
                }
                
                const data = snapshot.val();
                const previousPlayerIndex = state.gameState?.currentPlayerIndex;
                const previousGeneration = state.gameState?.generation;
                
                state.gameState = data;
                state.players = data.players || {};
                
                if (data.state === 'playing') {
                    updateGameUI(data);
                    
                    // Reset warning flags when turn changes
                    if (previousPlayerIndex !== data.currentPlayerIndex) {
                        state.warningPlayed = false;
                        state.timeUpPlayed = false;
                        state.lastWarningTime = -1;
                    }
                } else if (data.state === 'waiting') {
                    // Game ended, back to waiting room
                    enterWaitingRoom();
                }
            });
            unsubscribers.push(() => off(roomRef));
            
            // Start local timer loop (100ms updates)
            state.localTimerInterval = setInterval(() => {
                if (!state.gameState || state.gameState.isPaused) return;
                
                const now = Date.now();
                const elapsed = (now - state.gameState.turnStartTime) / 1000;
                const remaining = state.gameState.turnDuration - elapsed;
                
                updateTimerDisplay(remaining);
                
                // Host plays sounds at specific times
                if (state.isHost && !state.isMuted) {
                    const roundedRemaining = Math.floor(remaining);
                    
                    // EXACTLY at 5 seconds - play warning beep
                    if (roundedRemaining === 5 && !state.warningPlayed && remaining <= 5.1 && remaining > 4.9) {
                        playWarning();
                        state.warningPlayed = true;
                        console.log('Warning played at', remaining);
                    }
                    
                    // EXACTLY at 0 seconds - play time up sound
                    if (roundedRemaining <= 0 && !state.timeUpPlayed && remaining <= 0.1 && remaining > -0.5) {
                        playTimeUp();
                        state.timeUpPlayed = true;
                        console.log('Time up played at', remaining);
                    }
                }
            }, 50); // 50ms for more precise timing
            
            // Game elapsed timer
            state.gameTimerInterval = setInterval(() => {
                if (!state.gameState || !state.gameState.gameStartTime) return;
                const elapsed = Math.floor((Date.now() - state.gameState.gameStartTime) / 1000);
                el.gameTimer.textContent = formatGameTime(elapsed);
            }, 1000);
        }
        
        function updateTimerDisplay(remaining) {
            el.timerText.textContent = formatTime(remaining);
            
            const progress = Math.min(1, Math.max(0, (state.gameState.turnDuration - remaining) / state.gameState.turnDuration));
            const circumference = 2 * Math.PI * 130;
            el.timerProgress.style.strokeDashoffset = circumference * (1 - progress);
            
            el.timerText.classList.toggle('overtime', remaining < 0);
            el.timerText.classList.toggle('warning', remaining <= 5 && remaining > 0);
            el.timerProgress.classList.toggle('overtime', remaining < 0);
        }
        
        function updateGameUI(data) {
            el.genNumber.textContent = data.generation || 1;
            
            const playerOrder = data.playerOrder || [];
            const currentPlayerId = playerOrder[data.currentPlayerIndex];
            const currentPlayer = data.players?.[currentPlayerId];
            
            if (currentPlayer) {
                el.currentPlayerName.textContent = currentPlayer.name;
                el.currentPlayerName.style.color = COLOR_HEX[currentPlayer.color];
                
                const isMyTurn = currentPlayerId === state.playerId;
                el.currentPlayerLabel.textContent = isMyTurn ? 'Twoja tura!' : 'Tura gracza';
                
                // Pass button state
                el.passBtn.disabled = !isMyTurn || data.isPaused;
                el.passGenBtn.disabled = !isMyTurn || data.isPaused;
                
                // Update colors
                const timerGradient = document.querySelector('#timerGradient');
                if (timerGradient) {
                    timerGradient.innerHTML = `<stop offset="0%" style="stop-color:${COLOR_HEX[currentPlayer.color]}"/><stop offset="100%" style="stop-color:${COLOR_HEX[currentPlayer.color]}"/>`;
                }
                el.passBtn.style.background = `linear-gradient(135deg, ${COLOR_HEX[currentPlayer.color]}, ${COLOR_HEX[currentPlayer.color]})`;
                el.passBtn.style.boxShadow = `0 8px 32px ${COLOR_HEX[currentPlayer.color]}66`;
            }
            
            // Players strip
            const startIndex = data.startPlayerIndex || 0;
            const orderedPlayers = [];
            for (let i = 0; i < playerOrder.length; i++) {
                const idx = (startIndex + i) % playerOrder.length;
                const pid = playerOrder[idx];
                const p = data.players?.[pid];
                if (p) orderedPlayers.push({ id: pid, ...p, originalIndex: idx });
            }
            
            el.playersStrip.innerHTML = orderedPlayers.map(p => {
                let statusClass = '';
                let statusText = '';
                if (p.passedGen) { statusClass = 'passed-gen'; statusText = 'GEN'; }
                else if (p.id === currentPlayerId) { statusClass = 'active'; }
                if (!p.online) statusClass += ' offline';
                
                return `<div class="player-chip ${statusClass}">
                    <div class="player-chip-dot" style="background: ${COLOR_HEX[p.color]}"></div>
                    <span>${p.name}</span>
                    ${statusText ? `<span class="player-chip-status">${statusText}</span>` : ''}
                </div>`;
            }).join('');
            
            // Admin overlay
            if (data.isPaused) {
                el.adminOverlay.classList.add('active');
                el.overlayTitle.textContent = data.overlayTitle || 'Admin Time';
                el.overlayText.textContent = data.overlayText || 'Gra wstrzymana';
                el.resumeBtn.textContent = data.overlayButton || 'Wzn√≥w grƒô';
            } else {
                el.adminOverlay.classList.remove('active');
            }
            
            // Next gen button visibility
            const allPassed = playerOrder.every(pid => data.players?.[pid]?.passedGen);
            el.nextGenBtn.style.display = allPassed && state.isHost ? 'block' : 'none';
            
            // Admin time button
            el.adminTimeBtn.classList.toggle('active', data.isPaused);
        }
        
        // =============================================
        // GAME ACTIONS
        // =============================================
        
        // Regular PASS - just passes turn to next player
        async function pass() {
            if (!state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            const currentPlayerId = playerOrder[state.gameState.currentPlayerIndex];
            
            if (currentPlayerId !== state.playerId) return;
            
            // Find next active player (not passedGen)
            let nextIndex = state.gameState.currentPlayerIndex;
            let attempts = 0;
            do {
                nextIndex = (nextIndex + 1) % playerOrder.length;
                attempts++;
            } while (state.players[playerOrder[nextIndex]]?.passedGen && attempts < playerOrder.length);
            
            const nextPlayerId = playerOrder[nextIndex];
            const nextPlayer = state.players[nextPlayerId];
            
            await update(ref(db, `rooms/${state.roomId}`), {
                currentPlayerIndex: nextIndex,
                turnStartTime: Date.now()
            });
            
            // Host announces next player
            if (state.isHost) {
                playTurnStart();
                speak(nextPlayer?.name);
            }
        }
        
        // PASS GEN - player passes for the generation
        async function passGen() {
            if (!state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            const currentPlayerId = playerOrder[state.gameState.currentPlayerIndex];
            
            if (currentPlayerId !== state.playerId) return;
            
            // Mark current player as passed
            await update(ref(db, `rooms/${state.roomId}/players/${state.playerId}`), {
                passedGen: true
            });
            
            // Check how many active players remain AFTER this player passes
            const updatedPlayers = { ...state.players };
            updatedPlayers[state.playerId].passedGen = true;
            
            const activePlayers = playerOrder.filter(pid => !updatedPlayers[pid]?.passedGen);
            const allPassed = activePlayers.length === 0;
            
            if (allPassed) {
                // SCENARIO B: This was the LAST active player
                // Say "Koniec pokolenia {numer}" (NOT "X spasowa≈Ç")
                if (state.isHost) {
                    const genNum = state.gameState.generation;
                    const ordinal = getPolishOrdinal(genNum);
                    speak(`Koniec pokolenia ${ordinal}`, true);
                }
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    isPaused: true,
                    overlayTitle: 'Koniec pokolenia ' + state.gameState.generation,
                    overlayText: 'Wszyscy spasowali',
                    overlayButton: 'üöÄ Nastƒôpne Pokolenie'
                });
            } else {
                // SCENARIO A: There are still other active players
                // Say "{Imiƒô} spasowa≈Ç", then announce next player
                
                // Find next active player
                let nextIndex = state.gameState.currentPlayerIndex;
                let attempts = 0;
                do {
                    nextIndex = (nextIndex + 1) % playerOrder.length;
                    attempts++;
                } while (updatedPlayers[playerOrder[nextIndex]]?.passedGen && attempts < playerOrder.length);
                
                const nextPlayerId = playerOrder[nextIndex];
                const nextPlayer = state.players[nextPlayerId];
                
                if (state.isHost) {
                    // Announce who passed
                    speak(`${state.playerName} spasowa≈Ç`);
                    
                    // After a delay, announce next player and play turn start sound
                    setTimeout(() => {
                        playTurnStart();
                        speak(nextPlayer?.name);
                    }, 1500);
                }
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    currentPlayerIndex: nextIndex,
                    turnStartTime: Date.now() + (state.isHost ? 1500 : 0) // Delay for host's speech
                });
            }
        }
        
        // NEXT GENERATION - start new generation
        async function nextGeneration() {
            if (!state.isHost || !state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            const newGeneration = state.gameState.generation + 1;
            const newStartIndex = (state.gameState.startPlayerIndex + 1) % playerOrder.length;
            
            // Get the first player of new generation
            const firstPlayerId = playerOrder[newStartIndex];
            const firstPlayer = state.players[firstPlayerId];
            
            // Announce new generation
            const ordinal = getPolishOrdinal(newGeneration);
            speak(`Pokolenie ${ordinal}`, true);
            
            // Reset all passedGen and update game state
            const updates = {
                generation: newGeneration,
                currentPlayerIndex: newStartIndex,
                startPlayerIndex: newStartIndex,
                turnStartTime: Date.now() + 2000, // Delay for speech
                isPaused: false
            };
            
            playerOrder.forEach(pid => {
                updates[`players/${pid}/passedGen`] = false;
            });
            
            await update(ref(db, `rooms/${state.roomId}`), updates);
            
            // After generation announcement, announce first player
            setTimeout(() => {
                playTurnStart();
                speak(firstPlayer?.name);
            }, 2000);
        }
        
        // ADMIN TIME - pause/resume game
        async function toggleAdminTime() {
            if (!state.isHost || !state.gameState) return;
            
            const isPaused = !state.gameState.isPaused;
            
            if (isPaused) {
                // Pausing - say "Admin time"
                speak('Admin time', true);
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    isPaused: true,
                    pausedAt: Date.now(),
                    overlayTitle: 'Admin Time',
                    overlayText: 'Gra wstrzymana',
                    overlayButton: 'Wzn√≥w grƒô'
                });
            } else {
                // Resuming - adjust turn time
                const pauseDuration = Date.now() - (state.gameState.pausedAt || Date.now());
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    isPaused: false,
                    turnStartTime: state.gameState.turnStartTime + pauseDuration
                });
            }
        }
        
        // FORCE NEXT TURN - host forces turn change
        async function forceNextTurn() {
            if (!state.isHost || !state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            let nextIndex = state.gameState.currentPlayerIndex;
            let attempts = 0;
            
            // Find next active player
            do {
                nextIndex = (nextIndex + 1) % playerOrder.length;
                attempts++;
            } while (state.players[playerOrder[nextIndex]]?.passedGen && attempts < playerOrder.length);
            
            const nextPlayerId = playerOrder[nextIndex];
            const nextPlayer = state.players[nextPlayerId];
            
            await update(ref(db, `rooms/${state.roomId}`), {
                currentPlayerIndex: nextIndex,
                turnStartTime: Date.now()
            });
            
            playTurnStart();
            speak(nextPlayer?.name);
        }
        
        async function leaveRoom() {
            // Clean up listeners
            unsubscribers.forEach(unsub => unsub());
            unsubscribers = [];
            
            // Clear intervals
            if (state.localTimerInterval) clearInterval(state.localTimerInterval);
            if (state.gameTimerInterval) clearInterval(state.gameTimerInterval);
            
            // Stop TTS
            TTS.stop();
            
            // If we're in a room, update our status
            if (state.roomId && state.playerId) {
                try {
                    if (state.isHost) {
                        // Host leaving = delete room
                        await remove(ref(db, `rooms/${state.roomId}`));
                    } else {
                        // Player leaving = just remove player
                        await remove(ref(db, `rooms/${state.roomId}/players/${state.playerId}`));
                    }
                } catch(e) {}
            }
            
            // Reset state
            state.roomId = null;
            state.playerId = null;
            state.isHost = false;
            state.gameState = null;
            state.players = {};
            state.lastWarningTime = -1;
            state.warningPlayed = false;
            state.timeUpPlayed = false;
            
            clearSession();
            document.body.classList.remove('is-host');
            el.hostOnlySection.style.display = 'none';
            el.hostSoundSection.style.display = 'none';
            el.timeSettingMini.style.display = 'none';
            showScreen('lobbyScreen');
            el.joinForm.classList.remove('active');
        }
        
        // =============================================
        // HOLD FOR PASS GEN
        // =============================================
        function startHold() {
            if (el.passGenBtn.disabled) return;
            state.holdProgress = 0;
            const progressFill = el.passGenBtn.querySelector('.progress-fill');
            state.holdTimeout = setInterval(() => {
                state.holdProgress += 10;
                progressFill.style.width = state.holdProgress + '%';
                if (state.holdProgress >= 100) endHold(true);
            }, 50);
        }
        
        function endHold(confirmed = false) {
            if (state.holdTimeout) {
                clearInterval(state.holdTimeout);
                state.holdTimeout = null;
            }
            el.passGenBtn.querySelector('.progress-fill').style.width = '0%';
            state.holdProgress = 0;
            if (confirmed) passGen();
        }
        
        // =============================================
        // EVENT LISTENERS
        // =============================================
        el.createRoomBtn.addEventListener('click', createRoom);
        
        el.showJoinBtn.addEventListener('click', () => {
            el.joinForm.classList.toggle('active');
            el.joinCodeInput.focus();
        });
        
        el.joinCodeInput.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase().replace(/[^A-Z]/g, '');
        });
        
        el.joinRoomBtn.addEventListener('click', () => {
            const code = el.joinCodeInput.value;
            if (code.length === 4) joinRoom(code);
        });
        
        el.joinCodeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && el.joinCodeInput.value.length === 4) joinRoom(el.joinCodeInput.value);
        });
        
        el.colorPicker.addEventListener('click', (e) => {
            const option = e.target.closest('.color-option');
            if (option) {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                state.playerColor = option.dataset.color;
            }
        });
        
        el.confirmNameBtn.addEventListener('click', confirmPlayer);
        el.playerNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') confirmPlayer();
        });
        
        el.timeUpMini.addEventListener('click', () => updateTurnDuration(5));
        el.timeDownMini.addEventListener('click', () => updateTurnDuration(-5));
        
        el.startGameBtn.addEventListener('click', startGame);
        el.leaveRoomBtn.addEventListener('click', leaveRoom);
        
        el.passBtn.addEventListener('click', pass);
        
        el.passGenBtn.addEventListener('mousedown', startHold);
        el.passGenBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(); }, { passive: false });
        el.passGenBtn.addEventListener('mouseup', () => endHold(false));
        el.passGenBtn.addEventListener('mouseleave', () => endHold(false));
        el.passGenBtn.addEventListener('touchend', () => endHold(false));
        el.passGenBtn.addEventListener('touchcancel', () => endHold(false));
        
        el.adminTimeBtn.addEventListener('click', toggleAdminTime);
        
        el.resumeBtn.addEventListener('click', () => {
            if (state.gameState?.overlayButton?.includes('Pokolenie')) {
                nextGeneration();
            } else {
                toggleAdminTime();
            }
        });
        
        el.menuBtn.addEventListener('click', () => {
            el.hostPanel.classList.add('open');
            el.hostPanelBackdrop.classList.add('open');
        });
        
        el.closePanelBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
        });
        
        el.hostPanelBackdrop.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
        });
        
        el.nextGenBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
            nextGeneration();
        });
        
        el.forceNextBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
            forceNextTurn();
        });
        
        el.hostAdminBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
            toggleAdminTime();
        });
        
        el.muteBtn.addEventListener('click', () => {
            state.isMuted = !state.isMuted;
            el.muteBtn.textContent = state.isMuted ? 'üîá W≈ÇƒÖcz d≈∫wiƒôki' : 'üîä Wycisz d≈∫wiƒôki';
            if (state.isMuted) {
                TTS.stop();
            }
        });
        
        el.leaveGameBtn.addEventListener('click', () => {
            if (confirm(state.isHost ? 'Jako host, opuszczenie gry zamknie pok√≥j dla wszystkich. Kontynuowaƒá?' : 'Czy na pewno chcesz opu≈õciƒá grƒô?')) {
                el.hostPanel.classList.remove('open');
                el.hostPanelBackdrop.classList.remove('open');
                leaveRoom();
            }
        });
        
        // Prevent double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) e.preventDefault();
            lastTouchEnd = now;
        }, false);
        
        // =============================================
        // INITIALIZATION
        // =============================================
        async function init() {
            requestWakeLock();
            
            // Pre-load voices for TTS
            if ('speechSynthesis' in window) {
                TTS.init();
                // Force voice loading
                speechSynthesis.getVoices();
            }
            
            // Check URL for room code
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');
            
            if (roomCode) {
                el.joinCodeInput.value = roomCode;
                el.joinForm.classList.add('active');
            }
            
            // Check for saved session (auto-reconnect)
            const session = loadSession();
            if (session && session.roomId) {
                try {
                    const roomRef = ref(db, `rooms/${session.roomId}`);
                    const snapshot = await get(roomRef);
                    
                    if (snapshot.exists()) {
                        const roomData = snapshot.val();
                        if (roomData.players?.[session.playerId]) {
                            // Reconnect
                            state.roomId = session.roomId;
                            state.playerId = session.playerId;
                            state.playerName = session.playerName;
                            state.playerColor = session.playerColor;
                            state.isHost = session.isHost;
                            state.turnDuration = roomData.turnDuration || 45;
                            
                            if (state.isHost) {
                                initAudio();
                                document.body.classList.add('is-host');
                                el.hostOnlySection.style.display = 'block';
                                el.hostSoundSection.style.display = 'block';
                                el.timeSettingMini.style.display = 'flex';
                            }
                            
                            // Update online status
                            await update(ref(db, `rooms/${state.roomId}/players/${state.playerId}`), { online: true });
                            onDisconnect(ref(db, `rooms/${state.roomId}/players/${state.playerId}`)).update({ online: false });
                            
                            if (roomData.state === 'playing') {
                                startGameListener();
                            } else {
                                enterWaitingRoom();
                            }
                            return;
                        }
                    }
                } catch(e) {
                    console.log('Reconnect failed:', e);
                }
                clearSession();
            }
        }
        
        init();
    </script>
</body>
</html>
