<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0a0118">
    <title>Mars Timer | Multiplayer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Exo+2:wght@300;400;500;600;700;800&subset=latin-ext&display=swap" rel="stylesheet">
</head>
<body>
    <div class="galaxy-bg"></div>
    <div class="stars"></div>
    <div class="bg-overlay"></div>
    
    <svg class="svg-defs">
        <defs>
            <linearGradient id="timerGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#a855f7"/>
                <stop offset="100%" style="stop-color:#ec4899"/>
            </linearGradient>
        </defs>
    </svg>
    
    <div class="connection-status" id="connectionStatus">‚ö† Brak po≈ÇƒÖczenia...</div>
    
    <!-- LOBBY SCREEN -->
    <div class="screen lobby-screen active" id="lobbyScreen">
        <div class="lobby-logo">
            <h1>Mars Timer</h1>
            <p>Multiplayer</p>
        </div>
        <div class="lobby-actions">
            <button class="lobby-btn primary" id="createRoomBtn">Stw√≥rz pok√≥j</button>
            <div class="lobby-divider">lub</div>
            <button class="lobby-btn secondary" id="showJoinBtn">Do≈ÇƒÖcz do gry</button>
        </div>
        <div class="join-form" id="joinForm">
            <input type="text" class="join-input" id="joinCodeInput" placeholder="KOD" maxlength="4" autocomplete="off">
            <button class="lobby-btn primary" id="joinRoomBtn">Do≈ÇƒÖcz</button>
        </div>
    </div>
    
    <!-- NAME MODAL -->
    <div class="name-modal" id="nameModal">
        <div class="name-modal-content">
            <h2>Jak masz na imiƒô?</h2>
            <p>Wybierz sw√≥j kolor</p>
            <input type="text" class="name-input" id="playerNameInput" placeholder="Twoje imiƒô" maxlength="12">
            <div class="color-picker" id="colorPicker">
                <div class="color-option blue selected" data-color="blue"></div>
                <div class="color-option red" data-color="red"></div>
                <div class="color-option green" data-color="green"></div>
                <div class="color-option yellow" data-color="yellow"></div>
                <div class="color-option black" data-color="black"></div>
            </div>
            <button class="lobby-btn primary" id="confirmNameBtn">Potwierd≈∫</button>
        </div>
    </div>
    
    <!-- WAITING ROOM -->
    <div class="screen waiting-screen" id="waitingScreen">
        <div class="room-header">
            <div class="room-code-label">Kod pokoju</div>
            <div class="room-code" id="roomCodeDisplay">----</div>
            <div class="qr-container" id="qrContainer"></div>
        </div>
        <div class="time-setting-mini" id="timeSettingMini" style="display:none;">
            <div class="time-label-mini">Czas tury:</div>
            <button class="time-btn-mini" id="timeDownMini">‚àí</button>
            <div class="time-display-mini"><span id="timeValueMini">45</span>s</div>
            <button class="time-btn-mini" id="timeUpMini">+</button>
        </div>
        <div class="players-waiting">
            <div class="players-waiting-title">Gracze w pokoju</div>
            <div id="waitingPlayersList"></div>
        </div>
        <div class="waiting-actions">
            <button class="start-game-btn" id="startGameBtn" disabled>Czekam na graczy...</button>
            <button class="leave-btn" id="leaveRoomBtn">Opu≈õƒá pok√≥j</button>
        </div>
    </div>
    
    <!-- GAME SCREEN -->
    <div class="screen game-screen" id="gameScreen">
        <div class="generation-bar">
            <div class="generation-info">
                <span class="generation-label">Pokolenie</span>
                <span class="generation-number" id="genNumber">1</span>
            </div>
            <div class="game-timer" id="gameTimer">0:00</div>
            <button class="menu-btn" id="menuBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="players-strip" id="playersStrip"></div>
        <div class="timer-area">
            <div class="current-player-name" id="currentPlayerName">---</div>
            <div class="current-player-label" id="currentPlayerLabel">Tura gracza</div>
            <div class="timer-display">
                <div class="mars-planet">
                    <img src="https://upload.wikimedia.org/wikipedia/commons/0/02/OSIRIS_Mars_true_color.jpg" alt="Mars">
                </div>
                <div class="timer-overlay"></div>
                <div class="timer-ring">
                    <svg viewBox="0 0 280 280">
                        <circle class="timer-ring-bg" cx="140" cy="140" r="130"/>
                        <circle class="timer-ring-progress" id="timerProgress" cx="140" cy="140" r="130"/>
                    </svg>
                </div>
                <div class="timer-text" id="timerText">0:45</div>
            </div>
        </div>
        <div class="action-area">
            <button class="pass-btn" id="passBtn">PASS</button>
            <div class="secondary-actions">
                <button class="action-btn pass-gen" id="passGenBtn"><div class="progress-fill"></div><span>Pass Gen</span></button>
                <button class="action-btn admin-time host-only" id="adminTimeBtn">Admin Time</button>
            </div>
        </div>
        <div class="admin-overlay" id="adminOverlay">
            <svg class="admin-overlay-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
            <h2 id="overlayTitle">Admin Time</h2>
            <p id="overlayText">Gra wstrzymana</p>
            <button class="resume-btn host-only" id="resumeBtn">Wzn√≥w grƒô</button>
        </div>
    </div>
    
    <!-- HOST PANEL -->
    <div class="host-panel-backdrop" id="hostPanelBackdrop"></div>
    <div class="host-panel" id="hostPanel">
        <div class="host-panel-header">
            <h2>Panel</h2>
            <button class="close-panel-btn" id="closePanelBtn">‚úï</button>
        </div>
        <div class="host-panel-section" id="hostOnlySection" style="display:none;">
            <div class="host-panel-section-title">Kontrola gry (Host)</div>
            <button class="host-action-btn next-gen-btn" id="nextGenBtn" style="display:none;">üöÄ Nastƒôpne Pokolenie</button>
            <button class="host-action-btn" id="forceNextBtn">‚è≠ Nastƒôpna tura</button>
            <button class="host-action-btn" id="hostAdminBtn">‚è∏ Admin Time</button>
        </div>
        <div class="host-panel-section" id="hostSoundSection" style="display:none;">
            <div class="host-panel-section-title">D≈∫wiƒôk</div>
            <button class="host-action-btn" id="muteBtn">üîä Wycisz d≈∫wiƒôki</button>
        </div>
        <div class="host-panel-section">
            <div class="host-panel-section-title">Pok√≥j</div>
            <button class="host-action-btn danger" id="leaveGameBtn">üö™ Opu≈õƒá grƒô</button>
        </div>
        <div class="room-info-small">Kod pokoju: <span id="roomCodeSmall">----</span></div>
    </div>

    <!-- QRCode Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    
    <!-- Firebase -->
    <script type="module">
        // =============================================
        // FIREBASE CONFIG
        // =============================================
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { 
            getDatabase, ref, set, get, onValue, off, update, remove, onDisconnect, serverTimestamp 
        } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyCQwMpiRgAIXs7g6el_35HepBqOcm6gQVU",
            authDomain: "tm-timer-nw.firebaseapp.com",
            databaseURL: "https://tm-timer-nw-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "tm-timer-nw",
            storageBucket: "tm-timer-nw.firebasestorage.app",
            messagingSenderId: "425133932279",
            appId: "1:425133932279:web:c631018437f5dcdf115df2"
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        
        // =============================================
        // CONSTANTS
        // =============================================
        const COLORS = ['blue', 'red', 'green', 'yellow', 'black'];
        const COLOR_HEX = { red: '#f43f5e', blue: '#3b82f6', green: '#22c55e', yellow: '#facc15', black: '#6b7280' };
        
        // Polish ordinal numbers for generation announcement
        const POLISH_ORDINALS = {
            1: 'pierwsze', 2: 'drugie', 3: 'trzecie', 4: 'czwarte', 5: 'piƒÖte',
            6: 'sz√≥ste', 7: 'si√≥dme', 8: '√≥sme', 9: 'dziewiƒÖte', 10: 'dziesiƒÖte',
            11: 'jedenaste', 12: 'dwunaste', 13: 'trzynaste', 14: 'czternaste', 15: 'piƒôtnaste',
            16: 'szesnaste', 17: 'siedemnaste', 18: 'osiemnaste', 19: 'dziewiƒôtnaste', 20: 'dwudzieste'
        };
        
        // =============================================
        // STATE
        // =============================================
        let state = {
            roomId: null,
            playerId: null,
            playerName: '',
            playerColor: 'blue',
            isHost: false,
            isMuted: false,
            turnDuration: 45,
            players: {},
            gameState: null,
            localTimerInterval: null,
            gameTimerInterval: null,
            audioContext: null,
            holdTimeout: null,
            holdProgress: 0,
            // KLUCZOWE: u≈ºywamy turnStartTime jako unikalnego markera tury
            lastAnnouncedTurnTime: 0,
            lastAnnouncedGeneration: 0,
            warningPlayed: false,
            timeUpPlayed: false
        };
        
        let unsubscribers = [];
        
        // =============================================
        // TTS (TEXT-TO-SPEECH) MODULE - NAPRAWIONY
        // =============================================
        const TTS = {
            isUnlocked: false,
            voicesLoaded: false,
            polishVoice: null,
            unlockAttempts: 0,
            
            // Detect platform
            getPlatform() {
                const ua = navigator.userAgent;
                if (/iPad|iPhone|iPod/.test(ua) && !window.MSStream) return 'ios';
                if (/Android/.test(ua)) return 'android';
                return 'desktop';
            },
            
            // Initialize - call early
            init() {
                if (!('speechSynthesis' in window)) {
                    console.warn('[TTS] Speech Synthesis NOT supported in this browser');
                    return false;
                }
                
                console.log('[TTS] Initializing... Platform:', this.getPlatform());
                
                // Load voices immediately
                this.loadVoices();
                
                // iOS/Safari: voices load asynchronously
                speechSynthesis.onvoiceschanged = () => {
                    console.log('[TTS] onvoiceschanged fired');
                    this.loadVoices();
                };
                
                // Periodic voice check for stubborn browsers
                setTimeout(() => this.loadVoices(), 100);
                setTimeout(() => this.loadVoices(), 500);
                setTimeout(() => this.loadVoices(), 1000);
                
                return true;
            },
            
            // Load and find Polish voice
            loadVoices() {
                const voices = speechSynthesis.getVoices();
                console.log('[TTS] Available voices:', voices.length);
                
                if (voices.length === 0) {
                    console.log('[TTS] No voices yet, waiting...');
                    return;
                }
                
                this.voicesLoaded = true;
                
                // Find Polish voice
                const plVoices = voices.filter(v => v.lang && v.lang.startsWith('pl'));
                console.log('[TTS] Polish voices found:', plVoices.length, plVoices.map(v => v.name));
                
                if (plVoices.length > 0) {
                    // Prefer certain voices
                    this.polishVoice = plVoices.find(v => 
                        v.name.includes('Google') || 
                        v.name.includes('Zosia') ||
                        v.name.includes('Paulina') ||
                        v.name.includes('Microsoft')
                    ) || plVoices[0];
                    
                    console.log('[TTS] Selected Polish voice:', this.polishVoice.name);
                } else {
                    console.log('[TTS] No Polish voice found - will use lang fallback');
                    this.polishVoice = null;
                }
            },
            
            // CRITICAL: Unlock TTS - must be called from user gesture!
            async unlock() {
                if (this.isUnlocked) {
                    console.log('[TTS] Already unlocked');
                    return true;
                }
                
                console.log('[TTS] Attempting unlock... (attempt #' + (++this.unlockAttempts) + ')');
                
                const platform = this.getPlatform();
                
                try {
                    // Cancel any pending speech
                    speechSynthesis.cancel();
                    
                    // Method 1: Silent utterance (works on most platforms)
                    const utterance = new SpeechSynthesisUtterance(' ');
                    utterance.volume = 0.01; // Nearly silent
                    utterance.rate = 10; // Fast
                    utterance.lang = 'pl-PL';
                    
                    // Don't set voice on iOS - let it use default
                    if (platform !== 'ios' && this.polishVoice) {
                        utterance.voice = this.polishVoice;
                    }
                    
                    return new Promise((resolve) => {
                        utterance.onend = () => {
                            this.isUnlocked = true;
                            console.log('[TTS] Unlock SUCCESS via onend');
                            resolve(true);
                        };
                        
                        utterance.onerror = (e) => {
                            // Some errors are OK (interrupted, etc)
                            console.log('[TTS] Unlock utterance error:', e.error);
                            this.isUnlocked = true; // Try anyway
                            resolve(true);
                        };
                        
                        speechSynthesis.speak(utterance);
                        
                        // Timeout fallback
                        setTimeout(() => {
                            this.isUnlocked = true;
                            console.log('[TTS] Unlock via timeout fallback');
                            resolve(true);
                        }, 300);
                    });
                } catch (e) {
                    console.error('[TTS] Unlock error:', e);
                    this.isUnlocked = true; // Try anyway
                    return true;
                }
            },
            
            // Main speak function
            speak(text) {
                // Guards
                if (!state.isHost) {
                    console.log('[TTS] Not host, skipping:', text);
                    return;
                }
                
                if (state.isMuted) {
                    console.log('[TTS] Muted, skipping:', text);
                    return;
                }
                
                if (!('speechSynthesis' in window)) {
                    console.log('[TTS] No speechSynthesis support');
                    return;
                }
                
                console.log('[TTS] ‚ñ∂ SPEAKING:', text, '| Unlocked:', this.isUnlocked, '| Voice:', this.polishVoice?.name || 'default');
                
                const platform = this.getPlatform();
                
                // ALWAYS cancel before new speech (critical for iOS!)
                speechSynthesis.cancel();
                
                // Small delay after cancel (helps iOS)
                setTimeout(() => {
                    try {
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.lang = 'pl-PL';
                        utterance.rate = 1.0;
                        utterance.pitch = 0.95;
                        utterance.volume = 1.0;
                        
                        // Voice selection strategy by platform
                        if (platform === 'ios') {
                            // iOS: DON'T set voice object - just use lang
                            // Setting specific voice on iOS often breaks TTS
                            console.log('[TTS] iOS mode - using lang only');
                        } else if (platform === 'android') {
                            // Android: Try Polish voice, fallback to lang
                            if (this.polishVoice) {
                                utterance.voice = this.polishVoice;
                            }
                            console.log('[TTS] Android mode - voice:', utterance.voice?.name || 'default');
                        } else {
                            // Desktop: Use best voice if available
                            if (this.polishVoice) {
                                utterance.voice = this.polishVoice;
                            }
                            console.log('[TTS] Desktop mode - voice:', utterance.voice?.name || 'default');
                        }
                        
                        utterance.onstart = () => {
                            console.log('[TTS] ‚úì Speech started:', text);
                        };
                        
                        utterance.onend = () => {
                            console.log('[TTS] ‚úì Speech ended:', text);
                        };
                        
                        utterance.onerror = (e) => {
                            console.error('[TTS] ‚úó Speech error:', e.error, 'for text:', text);
                            
                            // Retry once on error (except 'interrupted' which is normal)
                            if (e.error !== 'interrupted' && e.error !== 'canceled') {
                                console.log('[TTS] Retrying speech...');
                                setTimeout(() => {
                                    const retry = new SpeechSynthesisUtterance(text);
                                    retry.lang = 'pl-PL';
                                    retry.rate = 1.0;
                                    speechSynthesis.speak(retry);
                                }, 100);
                            }
                        };
                        
                        // Chrome bug workaround: resume if paused
                        if (speechSynthesis.paused) {
                            speechSynthesis.resume();
                        }
                        
                        speechSynthesis.speak(utterance);
                        
                        // Chrome bug: speech can stop after ~15s, this helps
                        if (platform === 'desktop') {
                            setTimeout(() => {
                                if (speechSynthesis.speaking && speechSynthesis.paused) {
                                    speechSynthesis.resume();
                                }
                            }, 5000);
                        }
                        
                    } catch (e) {
                        console.error('[TTS] Speak exception:', e);
                    }
                }, platform === 'ios' ? 100 : 50); // Longer delay for iOS
            },
            
            // Stop all speech
            stop() {
                console.log('[TTS] Stopping all speech');
                speechSynthesis.cancel();
            }
        };
        
        // =============================================
        // DOM ELEMENTS
        // =============================================
        const $ = id => document.getElementById(id);
        const el = {
            connectionStatus: $('connectionStatus'),
            lobbyScreen: $('lobbyScreen'),
            waitingScreen: $('waitingScreen'),
            gameScreen: $('gameScreen'),
            nameModal: $('nameModal'),
            createRoomBtn: $('createRoomBtn'),
            showJoinBtn: $('showJoinBtn'),
            joinForm: $('joinForm'),
            joinCodeInput: $('joinCodeInput'),
            joinRoomBtn: $('joinRoomBtn'),
            playerNameInput: $('playerNameInput'),
            colorPicker: $('colorPicker'),
            confirmNameBtn: $('confirmNameBtn'),
            roomCodeDisplay: $('roomCodeDisplay'),
            qrContainer: $('qrContainer'),
            timeSettingMini: $('timeSettingMini'),
            timeValueMini: $('timeValueMini'),
            timeUpMini: $('timeUpMini'),
            timeDownMini: $('timeDownMini'),
            waitingPlayersList: $('waitingPlayersList'),
            startGameBtn: $('startGameBtn'),
            leaveRoomBtn: $('leaveRoomBtn'),
            genNumber: $('genNumber'),
            gameTimer: $('gameTimer'),
            playersStrip: $('playersStrip'),
            currentPlayerName: $('currentPlayerName'),
            currentPlayerLabel: $('currentPlayerLabel'),
            timerText: $('timerText'),
            timerProgress: $('timerProgress'),
            passBtn: $('passBtn'),
            passGenBtn: $('passGenBtn'),
            adminTimeBtn: $('adminTimeBtn'),
            adminOverlay: $('adminOverlay'),
            overlayTitle: $('overlayTitle'),
            overlayText: $('overlayText'),
            resumeBtn: $('resumeBtn'),
            menuBtn: $('menuBtn'),
            hostPanel: $('hostPanel'),
            hostPanelBackdrop: $('hostPanelBackdrop'),
            closePanelBtn: $('closePanelBtn'),
            hostOnlySection: $('hostOnlySection'),
            hostSoundSection: $('hostSoundSection'),
            nextGenBtn: $('nextGenBtn'),
            forceNextBtn: $('forceNextBtn'),
            hostAdminBtn: $('hostAdminBtn'),
            muteBtn: $('muteBtn'),
            leaveGameBtn: $('leaveGameBtn'),
            roomCodeSmall: $('roomCodeSmall')
        };
        
        // =============================================
        // UTILITY FUNCTIONS
        // =============================================
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            let code = '';
            for (let i = 0; i < 4; i++) code += chars[Math.floor(Math.random() * chars.length)];
            return code;
        }
        
        function generatePlayerId() {
            return 'p_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }
        
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            $(screenId).classList.add('active');
        }
        
        function formatTime(seconds) {
            const abs = Math.abs(Math.ceil(seconds));
            const mins = Math.floor(abs / 60);
            const secs = abs % 60;
            const sign = seconds < 0 ? '-' : '';
            return mins > 0 ? `${sign}${mins}:${secs.toString().padStart(2, '0')}` : `${sign}${secs}`;
        }
        
        function formatGameTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hrs > 0) return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Get Polish ordinal for generation number
        function getPolishOrdinal(num) {
            if (POLISH_ORDINALS[num]) return POLISH_ORDINALS[num];
            return num.toString();
        }
        
        // =============================================
        // AUDIO (HOST ONLY!) - SOUND EFFECTS
        // =============================================
        async function initAudio() {
            console.log('[AUDIO] Initializing audio system...');
            
            // Initialize AudioContext
            if (!state.audioContext) {
                try {
                    state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('[AUDIO] AudioContext created, state:', state.audioContext.state);
                } catch (e) {
                    console.error('[AUDIO] Failed to create AudioContext:', e);
                }
            }
            
            // Resume AudioContext if suspended
            if (state.audioContext && state.audioContext.state === 'suspended') {
                try {
                    await state.audioContext.resume();
                    console.log('[AUDIO] AudioContext resumed, state:', state.audioContext.state);
                } catch (e) {
                    console.error('[AUDIO] Failed to resume AudioContext:', e);
                }
            }
            
            // CRITICAL: Unlock TTS
            await TTS.unlock();
            
            console.log('[AUDIO] Audio initialization complete');
        }
        
        function playBeep(freq = 800, dur = 150, type = 'sine', volume = 0.3) {
            if (!state.isHost || !state.audioContext || state.isMuted) return;
            
            try {
                // Resume context if suspended
                if (state.audioContext.state === 'suspended') {
                    state.audioContext.resume();
                }
                
                const osc = state.audioContext.createOscillator();
                const gain = state.audioContext.createGain();
                osc.connect(gain);
                gain.connect(state.audioContext.destination);
                osc.frequency.value = freq;
                osc.type = type;
                gain.gain.setValueAtTime(volume, state.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + dur / 1000);
                osc.start(state.audioContext.currentTime);
                osc.stop(state.audioContext.currentTime + dur / 1000);
            } catch (e) {
                console.warn('[AUDIO] Beep error:', e);
            }
        }
        
        // Sound: Turn start (when switching to new player)
        function playTurnStart() {
            console.log('[AUDIO] Playing turn start sound');
            playBeep(600, 100);
            setTimeout(() => playBeep(800, 150), 120);
        }
        
        // Sound: 5-second warning
        function playWarning() {
            console.log('[AUDIO] Playing 5s warning');
            playBeep(880, 150, 'sine', 0.4);
        }
        
        // Sound: Time's up
        function playTimeUp() {
            console.log('[AUDIO] Playing time up sound');
            playBeep(300, 300, 'sawtooth', 0.5);
            setTimeout(() => playBeep(250, 400, 'sawtooth', 0.5), 350);
        }
        
        // =============================================
        // WAKE LOCK API
        // =============================================
        let wakeLock = null;
        
        async function requestWakeLock() {
            if (!('wakeLock' in navigator)) return;
            
            if (wakeLock !== null) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                } catch (e) {}
            }
            
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('[WAKE] Wake Lock acquired');
                
                wakeLock.addEventListener('release', () => {
                    console.log('[WAKE] Wake Lock released');
                    wakeLock = null;
                });
            } catch (err) {
                console.log('[WAKE] Wake Lock error:', err.name, err.message);
            }
        }
        
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
                console.log('[VISIBILITY] Page visible again');
                await requestWakeLock();
                
                if (state.audioContext && state.audioContext.state === 'suspended') {
                    state.audioContext.resume();
                }
            }
        });
        
        // =============================================
        // LOCAL STORAGE (Auto-Reconnect)
        // =============================================
        function saveSession() {
            localStorage.setItem('marsTimer_session', JSON.stringify({
                roomId: state.roomId,
                playerId: state.playerId,
                playerName: state.playerName,
                playerColor: state.playerColor,
                isHost: state.isHost
            }));
        }
        
        function loadSession() {
            try {
                const saved = localStorage.getItem('marsTimer_session');
                if (saved) return JSON.parse(saved);
            } catch(e) {}
            return null;
        }
        
        function clearSession() {
            localStorage.removeItem('marsTimer_session');
        }
        
        // =============================================
        // QR CODE
        // =============================================
        function generateQR(code) {
            el.qrContainer.innerHTML = '';
            const url = window.location.href.split('?')[0] + '?room=' + code;
            if (typeof QRCode !== 'undefined') {
                QRCode.toCanvas(url, { width: 120, margin: 1 }, (err, canvas) => {
                    if (!err) el.qrContainer.appendChild(canvas);
                });
            }
        }
        
        // =============================================
        // FIREBASE: ROOM MANAGEMENT
        // =============================================
        async function createRoom() {
            // CRITICAL: Initialize audio on user gesture
            await initAudio();
            
            const roomCode = generateRoomCode();
            state.roomId = roomCode;
            state.playerId = generatePlayerId();
            state.isHost = true;
            
            const roomRef = ref(db, `rooms/${roomCode}`);
            await set(roomRef, {
                host: state.playerId,
                state: 'waiting',
                turnDuration: state.turnDuration,
                createdAt: serverTimestamp()
            });
            
            showNameModal();
        }
        
        async function joinRoom(code) {
            // Initialize audio on user gesture (for future host promotion)
            await initAudio();
            
            const roomCode = code.toUpperCase();
            const roomRef = ref(db, `rooms/${roomCode}`);
            const snapshot = await get(roomRef);
            
            if (!snapshot.exists()) {
                alert('Nie znaleziono pokoju o tym kodzie!');
                return false;
            }
            
            const roomData = snapshot.val();
            if (roomData.state !== 'waiting') {
                alert('Gra ju≈º siƒô rozpoczƒô≈Ça!');
                return false;
            }
            
            state.roomId = roomCode;
            state.playerId = generatePlayerId();
            state.isHost = false;
            state.turnDuration = roomData.turnDuration || 45;
            
            showNameModal();
            return true;
        }
        
        function showNameModal() {
            el.nameModal.classList.add('active');
            el.playerNameInput.focus();
        }
        
        async function confirmPlayer() {
            const name = el.playerNameInput.value.trim();
            if (!name) {
                alert('Wpisz swoje imiƒô!');
                return;
            }
            
            // Re-unlock audio on this user gesture
            await initAudio();
            
            state.playerName = name;
            
            const playersRef = ref(db, `rooms/${state.roomId}/players`);
            const snapshot = await get(playersRef);
            const existingPlayers = snapshot.exists() ? Object.keys(snapshot.val()).length : 0;
            
            const playerRef = ref(db, `rooms/${state.roomId}/players/${state.playerId}`);
            await set(playerRef, {
                name: state.playerName,
                color: state.playerColor,
                passedGen: false,
                online: true,
                order: existingPlayers,
                isHost: state.isHost
            });
            
            onDisconnect(playerRef).update({ online: false });
            
            el.nameModal.classList.remove('active');
            saveSession();
            
            if (state.isHost) {
                document.body.classList.add('is-host');
                el.hostOnlySection.style.display = 'block';
                el.hostSoundSection.style.display = 'block';
                el.timeSettingMini.style.display = 'flex';
            }
            
            enterWaitingRoom();
        }
        
        function enterWaitingRoom() {
            showScreen('waitingScreen');
            el.roomCodeDisplay.textContent = state.roomId;
            el.roomCodeSmall.textContent = state.roomId;
            el.timeValueMini.textContent = state.turnDuration;
            generateQR(state.roomId);
            
            const roomRef = ref(db, `rooms/${state.roomId}`);
            const unsubRoom = onValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    alert('Pok√≥j zosta≈Ç zamkniƒôty');
                    leaveRoom();
                    return;
                }
                
                const data = snapshot.val();
                state.players = data.players || {};
                state.turnDuration = data.turnDuration || 45;
                el.timeValueMini.textContent = state.turnDuration;
                
                updateWaitingPlayersList();
                updateStartButton();
                
                if (data.state === 'playing') {
                    startGameListener();
                }
            });
            unsubscribers.push(() => off(roomRef));
            
            if (state.isHost) {
                el.startGameBtn.textContent = 'Rozpocznij grƒô';
            } else {
                el.startGameBtn.textContent = 'Czekam na hosta...';
                el.startGameBtn.disabled = true;
            }
        }
        
        function updateWaitingPlayersList() {
            const players = Object.entries(state.players).sort((a, b) => a[1].order - b[1].order);
            el.waitingPlayersList.innerHTML = players.map(([id, p]) => `
                <div class="player-waiting-item ${!p.online ? 'offline' : ''}">
                    <div class="player-waiting-color" style="background: ${COLOR_HEX[p.color]}"></div>
                    <div class="player-waiting-name">${p.name}</div>
                    ${p.isHost ? '<div class="player-waiting-host">Host</div>' : ''}
                    ${id === state.playerId ? '<div class="player-waiting-you">Ty</div>' : ''}
                </div>
            `).join('');
        }
        
        function updateStartButton() {
            if (!state.isHost) return;
            const onlinePlayers = Object.values(state.players).filter(p => p.online).length;
            el.startGameBtn.disabled = onlinePlayers < 2;
            el.startGameBtn.textContent = onlinePlayers < 2 ? 'Minimum 2 graczy' : 'Rozpocznij grƒô';
        }
        
        async function updateTurnDuration(delta) {
            if (!state.isHost) return;
            state.turnDuration = Math.max(15, Math.min(180, state.turnDuration + delta));
            await update(ref(db, `rooms/${state.roomId}`), { turnDuration: state.turnDuration });
        }
        
        async function startGame() {
            if (!state.isHost) return;
            
            // Re-init audio
            await initAudio();
            
            const players = Object.entries(state.players)
                .filter(([id, p]) => p.online)
                .sort((a, b) => a[1].order - b[1].order);
            const playerIds = players.map(([id]) => id);
            
            const turnStartTime = Date.now();
            
            await update(ref(db, `rooms/${state.roomId}`), {
                state: 'playing',
                generation: 1,
                currentPlayerIndex: 0,
                startPlayerIndex: 0,
                playerOrder: playerIds,
                turnStartTime: turnStartTime,
                turnDuration: state.turnDuration,
                isPaused: false,
                gameStartTime: Date.now()
            });
            
            // Mark this turn as announced
            state.lastAnnouncedTurnTime = turnStartTime;
            state.lastAnnouncedGeneration = 1;
            
            // Announce first player
            const firstPlayer = players[0][1];
            console.log('[GAME] Starting game, first player:', firstPlayer.name);
            playTurnStart();
            TTS.speak(firstPlayer.name);
        }
        
        function startGameListener() {
            showScreen('gameScreen');
            requestWakeLock();
            
            if (state.localTimerInterval) clearInterval(state.localTimerInterval);
            if (state.gameTimerInterval) clearInterval(state.gameTimerInterval);
            
            // Reset state
            state.warningPlayed = false;
            state.timeUpPlayed = false;
            
            const roomRef = ref(db, `rooms/${state.roomId}`);
            const unsubGame = onValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    leaveRoom();
                    return;
                }
                
                const data = snapshot.val();
                const prevGameState = state.gameState;
                
                state.gameState = data;
                state.players = data.players || {};
                
                if (data.state === 'playing') {
                    updateGameUI(data);
                    
                    // =============================================
                    // KLUCZOWA LOGIKA: Wykrywanie zmiany tury przez turnStartTime
                    // To dzia≈Ça nawet gdy index wraca do 0!
                    // =============================================
                    if (state.isHost && data.turnStartTime && !data.isPaused) {
                        const turnTimeChanged = data.turnStartTime !== state.lastAnnouncedTurnTime;
                        const generationChanged = data.generation !== state.lastAnnouncedGeneration;
                        
                        console.log('[TURN CHECK] turnStartTime:', data.turnStartTime, 
                                    'lastAnnounced:', state.lastAnnouncedTurnTime,
                                    'changed:', turnTimeChanged);
                        
                        if (turnTimeChanged) {
                            // Nowa tura! Og≈Ço≈õ gracza
                            const playerOrder = data.playerOrder || [];
                            const currentPlayerId = playerOrder[data.currentPlayerIndex];
                            const currentPlayer = data.players?.[currentPlayerId];
                            
                            if (currentPlayer) {
                                console.log('[TURN] New turn detected! Player:', currentPlayer.name, 
                                           'Index:', data.currentPlayerIndex);
                                
                                // Reset warning flags for new turn
                                state.warningPlayed = false;
                                state.timeUpPlayed = false;
                                
                                // Announce player (with small delay to not overlap with other sounds)
                                setTimeout(() => {
                                    playTurnStart();
                                    TTS.speak(currentPlayer.name);
                                }, 100);
                            }
                            
                            // Mark as announced
                            state.lastAnnouncedTurnTime = data.turnStartTime;
                        }
                        
                        // Track generation changes separately
                        if (generationChanged) {
                            state.lastAnnouncedGeneration = data.generation;
                        }
                    }
                    
                } else if (data.state === 'waiting') {
                    enterWaitingRoom();
                }
            });
            unsubscribers.push(() => off(roomRef));
            
            // Timer loop
            state.localTimerInterval = setInterval(() => {
                if (!state.gameState || state.gameState.isPaused) return;
                
                const now = Date.now();
                const elapsed = (now - state.gameState.turnStartTime) / 1000;
                const remaining = state.gameState.turnDuration - elapsed;
                
                updateTimerDisplay(remaining);
                
                // Warning sounds (host only)
                if (state.isHost && !state.isMuted) {
                    // 5 second warning
                    if (remaining <= 5.1 && remaining > 4.5 && !state.warningPlayed) {
                        playWarning();
                        state.warningPlayed = true;
                    }
                    
                    // Time up
                    if (remaining <= 0.1 && remaining > -0.5 && !state.timeUpPlayed) {
                        playTimeUp();
                        state.timeUpPlayed = true;
                    }
                }
            }, 50);
            
            // Game timer
            state.gameTimerInterval = setInterval(() => {
                if (!state.gameState || !state.gameState.gameStartTime) return;
                const elapsed = Math.floor((Date.now() - state.gameState.gameStartTime) / 1000);
                el.gameTimer.textContent = formatGameTime(elapsed);
            }, 1000);
        }
        
        function updateTimerDisplay(remaining) {
            el.timerText.textContent = formatTime(remaining);
            
            const progress = Math.min(1, Math.max(0, (state.gameState.turnDuration - remaining) / state.gameState.turnDuration));
            const circumference = 2 * Math.PI * 130;
            el.timerProgress.style.strokeDashoffset = circumference * (1 - progress);
            
            el.timerText.classList.toggle('overtime', remaining < 0);
            el.timerText.classList.toggle('warning', remaining <= 5 && remaining > 0);
            el.timerProgress.classList.toggle('overtime', remaining < 0);
        }
        
        function updateGameUI(data) {
            el.genNumber.textContent = data.generation || 1;
            
            const playerOrder = data.playerOrder || [];
            const currentPlayerId = playerOrder[data.currentPlayerIndex];
            const currentPlayer = data.players?.[currentPlayerId];
            
            if (currentPlayer) {
                el.currentPlayerName.textContent = currentPlayer.name;
                el.currentPlayerName.style.color = COLOR_HEX[currentPlayer.color];
                
                const isMyTurn = currentPlayerId === state.playerId;
                el.currentPlayerLabel.textContent = isMyTurn ? 'Twoja tura!' : 'Tura gracza';
                
                el.passBtn.disabled = !isMyTurn || data.isPaused;
                el.passGenBtn.disabled = !isMyTurn || data.isPaused;
                
                const timerGradient = document.querySelector('#timerGradient');
                if (timerGradient) {
                    timerGradient.innerHTML = `<stop offset="0%" style="stop-color:${COLOR_HEX[currentPlayer.color]}"/><stop offset="100%" style="stop-color:${COLOR_HEX[currentPlayer.color]}"/>`;
                }
                el.passBtn.style.background = `linear-gradient(135deg, ${COLOR_HEX[currentPlayer.color]}, ${COLOR_HEX[currentPlayer.color]})`;
                el.passBtn.style.boxShadow = `0 8px 32px ${COLOR_HEX[currentPlayer.color]}66`;
            }
            
            // Players strip
            const startIndex = data.startPlayerIndex || 0;
            const orderedPlayers = [];
            for (let i = 0; i < playerOrder.length; i++) {
                const idx = (startIndex + i) % playerOrder.length;
                const pid = playerOrder[idx];
                const p = data.players?.[pid];
                if (p) orderedPlayers.push({ id: pid, ...p, originalIndex: idx });
            }
            
            el.playersStrip.innerHTML = orderedPlayers.map(p => {
                let statusClass = '';
                let statusText = '';
                if (p.passedGen) { statusClass = 'passed-gen'; statusText = 'GEN'; }
                else if (p.id === currentPlayerId) { statusClass = 'active'; }
                if (!p.online) statusClass += ' offline';
                
                return `<div class="player-chip ${statusClass}">
                    <div class="player-chip-dot" style="background: ${COLOR_HEX[p.color]}"></div>
                    <span>${p.name}</span>
                    ${statusText ? `<span class="player-chip-status">${statusText}</span>` : ''}
                </div>`;
            }).join('');
            
            // Admin overlay
            if (data.isPaused) {
                el.adminOverlay.classList.add('active');
                el.overlayTitle.textContent = data.overlayTitle || 'Admin Time';
                el.overlayText.textContent = data.overlayText || 'Gra wstrzymana';
                el.resumeBtn.textContent = data.overlayButton || 'Wzn√≥w grƒô';
            } else {
                el.adminOverlay.classList.remove('active');
            }
            
            // Next gen button
            const allPassed = playerOrder.every(pid => data.players?.[pid]?.passedGen);
            el.nextGenBtn.style.display = allPassed && state.isHost ? 'block' : 'none';
            
            el.adminTimeBtn.classList.toggle('active', data.isPaused);
        }
        
        // =============================================
        // GAME ACTIONS
        // =============================================
        
        // Regular PASS
        async function pass() {
            if (!state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            const currentPlayerId = playerOrder[state.gameState.currentPlayerIndex];
            
            if (currentPlayerId !== state.playerId) return;
            
            // Find next active player
            let nextIndex = state.gameState.currentPlayerIndex;
            let attempts = 0;
            do {
                nextIndex = (nextIndex + 1) % playerOrder.length;
                attempts++;
            } while (state.players[playerOrder[nextIndex]]?.passedGen && attempts < playerOrder.length);
            
            // WA≈ªNE: U≈ºyj NOWEGO turnStartTime jako unikalnego markera!
            const newTurnTime = Date.now();
            
            console.log('[PASS] Passing turn. Current:', state.gameState.currentPlayerIndex, 
                       '-> Next:', nextIndex, 'NewTurnTime:', newTurnTime);
            
            // Update state - NIE og≈Çaszamy tutaj, og≈Çoszenie bƒôdzie przez Firebase listener
            // To zapewnia ≈ºe og≈Çoszenie dzia≈Ça nawet gdy inny gracz klika PASS
            await update(ref(db, `rooms/${state.roomId}`), {
                currentPlayerIndex: nextIndex,
                turnStartTime: newTurnTime
            });
        }
        
        // PASS GEN
        async function passGen() {
            if (!state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            const currentPlayerId = playerOrder[state.gameState.currentPlayerIndex];
            
            if (currentPlayerId !== state.playerId) return;
            
            // Mark current player as passed
            await update(ref(db, `rooms/${state.roomId}/players/${state.playerId}`), {
                passedGen: true
            });
            
            // Check remaining active players
            const updatedPlayers = { ...state.players };
            updatedPlayers[state.playerId].passedGen = true;
            
            const activePlayers = playerOrder.filter(pid => !updatedPlayers[pid]?.passedGen);
            const allPassed = activePlayers.length === 0;
            
            console.log('[PASS GEN] Player:', state.playerName, 'Active remaining:', activePlayers.length);
            
            if (allPassed) {
                // SCENARIO B: Last player - end generation
                if (state.isHost) {
                    const genNum = state.gameState.generation;
                    const ordinal = getPolishOrdinal(genNum);
                    TTS.speak(`Koniec pokolenia ${ordinal}`);
                }
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    isPaused: true,
                    overlayTitle: 'Koniec pokolenia ' + state.gameState.generation,
                    overlayText: 'Wszyscy spasowali',
                    overlayButton: 'üöÄ Nastƒôpne Pokolenie'
                });
            } else {
                // SCENARIO A: Others still active
                let nextIndex = state.gameState.currentPlayerIndex;
                let attempts = 0;
                do {
                    nextIndex = (nextIndex + 1) % playerOrder.length;
                    attempts++;
                } while (updatedPlayers[playerOrder[nextIndex]]?.passedGen && attempts < playerOrder.length);
                
                const nextPlayer = state.players[playerOrder[nextIndex]];
                const newTurnTime = Date.now() + 1800; // Delay for speech
                
                if (state.isHost) {
                    // Announce who passed
                    TTS.speak(`${state.playerName} spasowa≈Ç`);
                    
                    // Mark turn time so the listener will announce next player
                    state.lastAnnouncedTurnTime = newTurnTime;
                }
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    currentPlayerIndex: nextIndex,
                    turnStartTime: newTurnTime
                });
            }
        }
        
        // NEXT GENERATION
        async function nextGeneration() {
            if (!state.isHost || !state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            const newGeneration = state.gameState.generation + 1;
            const newStartIndex = (state.gameState.startPlayerIndex + 1) % playerOrder.length;
            
            const firstPlayerId = playerOrder[newStartIndex];
            const firstPlayer = state.players[firstPlayerId];
            
            // Announce generation FIRST
            const ordinal = getPolishOrdinal(newGeneration);
            TTS.speak(`Pokolenie ${ordinal}`);
            
            // Set turn time in future for delay
            const newTurnTime = Date.now() + 2500;
            
            // Mark as announced so listener doesn't double-announce
            state.lastAnnouncedTurnTime = newTurnTime;
            state.lastAnnouncedGeneration = newGeneration;
            
            const updates = {
                generation: newGeneration,
                currentPlayerIndex: newStartIndex,
                startPlayerIndex: newStartIndex,
                turnStartTime: newTurnTime,
                isPaused: false
            };
            
            playerOrder.forEach(pid => {
                updates[`players/${pid}/passedGen`] = false;
            });
            
            await update(ref(db, `rooms/${state.roomId}`), updates);
            
            // Announce first player after delay
            setTimeout(() => {
                playTurnStart();
                TTS.speak(firstPlayer?.name);
            }, 2500);
        }
        
        // ADMIN TIME
        async function toggleAdminTime() {
            if (!state.isHost || !state.gameState) return;
            
            const isPaused = !state.gameState.isPaused;
            
            if (isPaused) {
                // Pausing
                TTS.speak('Admin time');
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    isPaused: true,
                    pausedAt: Date.now(),
                    overlayTitle: 'Admin Time',
                    overlayText: 'Gra wstrzymana',
                    overlayButton: 'Wzn√≥w grƒô'
                });
            } else {
                // Resuming
                const pauseDuration = Date.now() - (state.gameState.pausedAt || Date.now());
                const newTurnTime = state.gameState.turnStartTime + pauseDuration;
                
                // Mark as announced so we don't re-announce current player
                state.lastAnnouncedTurnTime = newTurnTime;
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    isPaused: false,
                    turnStartTime: newTurnTime
                });
            }
        }
        
        // FORCE NEXT TURN
        async function forceNextTurn() {
            if (!state.isHost || !state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            let nextIndex = state.gameState.currentPlayerIndex;
            let attempts = 0;
            
            do {
                nextIndex = (nextIndex + 1) % playerOrder.length;
                attempts++;
            } while (state.players[playerOrder[nextIndex]]?.passedGen && attempts < playerOrder.length);
            
            const newTurnTime = Date.now();
            
            console.log('[FORCE NEXT] Forcing next turn. Current:', state.gameState.currentPlayerIndex, 
                       '-> Next:', nextIndex);
            
            // Mark as announced so we announce via listener
            // Actually no - let the listener handle it for consistency
            
            await update(ref(db, `rooms/${state.roomId}`), {
                currentPlayerIndex: nextIndex,
                turnStartTime: newTurnTime
            });
        }
        
        async function leaveRoom() {
            unsubscribers.forEach(unsub => unsub());
            unsubscribers = [];
            
            if (state.localTimerInterval) clearInterval(state.localTimerInterval);
            if (state.gameTimerInterval) clearInterval(state.gameTimerInterval);
            
            TTS.stop();
            
            if (state.roomId && state.playerId) {
                try {
                    if (state.isHost) {
                        await remove(ref(db, `rooms/${state.roomId}`));
                    } else {
                        await remove(ref(db, `rooms/${state.roomId}/players/${state.playerId}`));
                    }
                } catch(e) {}
            }
            
            state.roomId = null;
            state.playerId = null;
            state.isHost = false;
            state.gameState = null;
            state.players = {};
            state.lastAnnouncedTurnTime = 0;
            state.lastAnnouncedGeneration = 0;
            state.warningPlayed = false;
            state.timeUpPlayed = false;
            
            clearSession();
            document.body.classList.remove('is-host');
            el.hostOnlySection.style.display = 'none';
            el.hostSoundSection.style.display = 'none';
            el.timeSettingMini.style.display = 'none';
            showScreen('lobbyScreen');
            el.joinForm.classList.remove('active');
        }
        
        // =============================================
        // HOLD FOR PASS GEN
        // =============================================
        function startHold() {
            if (el.passGenBtn.disabled) return;
            state.holdProgress = 0;
            const progressFill = el.passGenBtn.querySelector('.progress-fill');
            state.holdTimeout = setInterval(() => {
                state.holdProgress += 10;
                progressFill.style.width = state.holdProgress + '%';
                if (state.holdProgress >= 100) endHold(true);
            }, 50);
        }
        
        function endHold(confirmed = false) {
            if (state.holdTimeout) {
                clearInterval(state.holdTimeout);
                state.holdTimeout = null;
            }
            el.passGenBtn.querySelector('.progress-fill').style.width = '0%';
            state.holdProgress = 0;
            if (confirmed) passGen();
        }
        
        // =============================================
        // EVENT LISTENERS
        // =============================================
        el.createRoomBtn.addEventListener('click', createRoom);
        
        el.showJoinBtn.addEventListener('click', () => {
            el.joinForm.classList.toggle('active');
            el.joinCodeInput.focus();
        });
        
        el.joinCodeInput.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase().replace(/[^A-Z]/g, '');
        });
        
        el.joinRoomBtn.addEventListener('click', () => {
            const code = el.joinCodeInput.value;
            if (code.length === 4) joinRoom(code);
        });
        
        el.joinCodeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && el.joinCodeInput.value.length === 4) joinRoom(el.joinCodeInput.value);
        });
        
        el.colorPicker.addEventListener('click', (e) => {
            const option = e.target.closest('.color-option');
            if (option) {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                state.playerColor = option.dataset.color;
            }
        });
        
        el.confirmNameBtn.addEventListener('click', confirmPlayer);
        el.playerNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') confirmPlayer();
        });
        
        el.timeUpMini.addEventListener('click', () => updateTurnDuration(5));
        el.timeDownMini.addEventListener('click', () => updateTurnDuration(-5));
        
        el.startGameBtn.addEventListener('click', startGame);
        el.leaveRoomBtn.addEventListener('click', leaveRoom);
        
        el.passBtn.addEventListener('click', pass);
        
        el.passGenBtn.addEventListener('mousedown', startHold);
        el.passGenBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(); }, { passive: false });
        el.passGenBtn.addEventListener('mouseup', () => endHold(false));
        el.passGenBtn.addEventListener('mouseleave', () => endHold(false));
        el.passGenBtn.addEventListener('touchend', () => endHold(false));
        el.passGenBtn.addEventListener('touchcancel', () => endHold(false));
        
        el.adminTimeBtn.addEventListener('click', toggleAdminTime);
        
        el.resumeBtn.addEventListener('click', () => {
            if (state.gameState?.overlayButton?.includes('Pokolenie')) {
                nextGeneration();
            } else {
                toggleAdminTime();
            }
        });
        
        el.menuBtn.addEventListener('click', () => {
            el.hostPanel.classList.add('open');
            el.hostPanelBackdrop.classList.add('open');
        });
        
        el.closePanelBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
        });
        
        el.hostPanelBackdrop.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
        });
        
        el.nextGenBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
            nextGeneration();
        });
        
        el.forceNextBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
            forceNextTurn();
        });
        
        el.hostAdminBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
            toggleAdminTime();
        });
        
        el.muteBtn.addEventListener('click', () => {
            state.isMuted = !state.isMuted;
            el.muteBtn.textContent = state.isMuted ? 'üîá W≈ÇƒÖcz d≈∫wiƒôki' : 'üîä Wycisz d≈∫wiƒôki';
            if (state.isMuted) {
                TTS.stop();
            }
        });
        
        el.leaveGameBtn.addEventListener('click', () => {
            if (confirm(state.isHost ? 'Jako host, opuszczenie gry zamknie pok√≥j dla wszystkich. Kontynuowaƒá?' : 'Czy na pewno chcesz opu≈õciƒá grƒô?')) {
                el.hostPanel.classList.remove('open');
                el.hostPanelBackdrop.classList.remove('open');
                leaveRoom();
            }
        });
        
        // Prevent double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) e.preventDefault();
            lastTouchEnd = now;
        }, false);
        
        // =============================================
        // INITIALIZATION
        // =============================================
        async function init() {
            console.log('[INIT] Mars Timer starting...');
            
            requestWakeLock();
            
            // Initialize TTS early (but unlock needs user gesture)
            TTS.init();
            
            // Check URL for room code
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');
            
            if (roomCode) {
                el.joinCodeInput.value = roomCode;
                el.joinForm.classList.add('active');
            }
            
            // Auto-reconnect
            const session = loadSession();
            if (session && session.roomId) {
                try {
                    const roomRef = ref(db, `rooms/${session.roomId}`);
                    const snapshot = await get(roomRef);
                    
                    if (snapshot.exists()) {
                        const roomData = snapshot.val();
                        if (roomData.players?.[session.playerId]) {
                            state.roomId = session.roomId;
                            state.playerId = session.playerId;
                            state.playerName = session.playerName;
                            state.playerColor = session.playerColor;
                            state.isHost = session.isHost;
                            state.turnDuration = roomData.turnDuration || 45;
                            
                            if (state.isHost) {
                                // Don't init audio yet - needs user gesture
                                document.body.classList.add('is-host');
                                el.hostOnlySection.style.display = 'block';
                                el.hostSoundSection.style.display = 'block';
                                el.timeSettingMini.style.display = 'flex';
                            }
                            
                            await update(ref(db, `rooms/${state.roomId}/players/${state.playerId}`), { online: true });
                            onDisconnect(ref(db, `rooms/${state.roomId}/players/${state.playerId}`)).update({ online: false });
                            
                            if (roomData.state === 'playing') {
                                // Set last announced to current to avoid re-announcing on reconnect
                                state.lastAnnouncedTurnTime = roomData.turnStartTime || 0;
                                state.lastAnnouncedGeneration = roomData.generation || 1;
                                startGameListener();
                            } else {
                                enterWaitingRoom();
                            }
                            return;
                        }
                    }
                } catch(e) {
                    console.log('[INIT] Reconnect failed:', e);
                }
                clearSession();
            }
            
            console.log('[INIT] Ready');
        }
        
        init();
    </script>
</body>
</html>