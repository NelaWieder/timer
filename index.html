<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0a0118">
    <title>Mars Timer | Multiplayer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Exo+2:wght@300;400;500;600;700;800&subset=latin-ext&display=swap" rel="stylesheet">
</head>
<body>
    <div class="galaxy-bg"></div>
    <div class="stars"></div>
    <div class="bg-overlay"></div>
    
    <svg class="svg-defs">
        <defs>
            <linearGradient id="timerGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#a855f7"/>
                <stop offset="100%" style="stop-color:#ec4899"/>
            </linearGradient>
        </defs>
    </svg>
    
    <div class="connection-status" id="connectionStatus">‚ö† Brak po≈ÇƒÖczenia...</div>
    
    <!-- LOBBY SCREEN -->
    <div class="screen lobby-screen active" id="lobbyScreen">
        <div class="lobby-logo">
            <h1>Mars Timer</h1>
            <p>Multiplayer</p>
        </div>
        <div class="lobby-actions">
            <button class="lobby-btn primary" id="createRoomBtn">Stw√≥rz pok√≥j</button>
            <div class="lobby-divider">lub</div>
            <button class="lobby-btn secondary" id="showJoinBtn">Do≈ÇƒÖcz do gry</button>
        </div>
        <div class="join-form" id="joinForm">
            <input type="text" class="join-input" id="joinCodeInput" placeholder="KOD" maxlength="4" autocomplete="off">
            <button class="lobby-btn primary" id="joinRoomBtn">Do≈ÇƒÖcz</button>
        </div>
    </div>
    
    <!-- NAME MODAL -->
    <div class="name-modal" id="nameModal">
        <div class="name-modal-content">
            <h2>Jak masz na imiƒô?</h2>
            <p>Wybierz sw√≥j kolor</p>
            <input type="text" class="name-input" id="playerNameInput" placeholder="Twoje imiƒô" maxlength="12">
            <div class="color-picker" id="colorPicker">
                <div class="color-option blue selected" data-color="blue"></div>
                <div class="color-option red" data-color="red"></div>
                <div class="color-option green" data-color="green"></div>
                <div class="color-option yellow" data-color="yellow"></div>
                <div class="color-option black" data-color="black"></div>
            </div>
            <button class="lobby-btn primary" id="confirmNameBtn">Potwierd≈∫</button>
        </div>
    </div>
    
    <!-- WAITING ROOM -->
    <div class="screen waiting-screen" id="waitingScreen">
        <div class="room-header">
            <div class="room-code-label">Kod pokoju</div>
            <div class="room-code" id="roomCodeDisplay">----</div>
            <div class="qr-container" id="qrContainer"></div>
        </div>
        <div class="time-setting-mini" id="timeSettingMini" style="display:none;">
            <div class="time-label-mini">Czas tury:</div>
            <button class="time-btn-mini" id="timeDownMini">‚àí</button>
            <div class="time-display-mini"><span id="timeValueMini">45</span>s</div>
            <button class="time-btn-mini" id="timeUpMini">+</button>
        </div>
        <div class="players-waiting">
            <div class="players-waiting-title">Gracze w pokoju</div>
            <div id="waitingPlayersList"></div>
        </div>
        <div class="waiting-actions">
            <button class="start-game-btn" id="startGameBtn" disabled>Czekam na graczy...</button>
            <button class="leave-btn" id="leaveRoomBtn">Opu≈õƒá pok√≥j</button>
        </div>
    </div>
    
    <!-- GAME SCREEN -->
    <div class="screen game-screen" id="gameScreen">
        <div class="generation-bar">
            <div class="generation-info">
                <span class="generation-label">Pokolenie</span>
                <span class="generation-number" id="genNumber">1</span>
            </div>
            <div class="game-timer" id="gameTimer">0:00</div>
            <button class="menu-btn" id="menuBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="players-strip" id="playersStrip"></div>
        <div class="timer-area">
            <div class="current-player-name" id="currentPlayerName">---</div>
            <div class="current-player-label" id="currentPlayerLabel">Tura gracza</div>
            <div class="timer-display">
                <div class="mars-planet">
                    <img src="https://upload.wikimedia.org/wikipedia/commons/0/02/OSIRIS_Mars_true_color.jpg" alt="Mars">
                </div>
                <div class="timer-overlay"></div>
                <div class="timer-ring">
                    <svg viewBox="0 0 280 280">
                        <circle class="timer-ring-bg" cx="140" cy="140" r="130"/>
                        <circle class="timer-ring-progress" id="timerProgress" cx="140" cy="140" r="130"/>
                    </svg>
                </div>
                <div class="timer-text" id="timerText">0:45</div>
            </div>
        </div>
        <div class="action-area">
            <button class="pass-btn" id="passBtn">PASS</button>
            <div class="secondary-actions">
                <button class="action-btn pass-gen" id="passGenBtn"><div class="progress-fill"></div><span>Pass Gen</span></button>
                <button class="action-btn admin-time host-only" id="adminTimeBtn">Admin Time</button>
            </div>
        </div>
        <div class="admin-overlay" id="adminOverlay">
            <svg class="admin-overlay-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
            <h2 id="overlayTitle">Admin Time</h2>
            <p id="overlayText">Gra wstrzymana</p>
            <button class="resume-btn host-only" id="resumeBtn">Wzn√≥w grƒô</button>
        </div>
    </div>
    
    <!-- HOST PANEL -->
    <div class="host-panel-backdrop" id="hostPanelBackdrop"></div>
    <div class="host-panel" id="hostPanel">
        <div class="host-panel-header">
            <h2>Panel</h2>
            <button class="close-panel-btn" id="closePanelBtn">‚úï</button>
        </div>
        <div class="host-panel-section" id="hostOnlySection" style="display:none;">
            <div class="host-panel-section-title">Kontrola gry (Host)</div>
            <button class="host-action-btn next-gen-btn" id="nextGenBtn" style="display:none;">üöÄ Nastƒôpne Pokolenie</button>
            <button class="host-action-btn" id="forceNextBtn">‚è≠ Nastƒôpna tura</button>
            <button class="host-action-btn" id="hostAdminBtn">‚è∏ Admin Time</button>
        </div>
        <div class="host-panel-section" id="hostSoundSection" style="display:none;">
            <div class="host-panel-section-title">D≈∫wiƒôk</div>
            <button class="host-action-btn" id="muteBtn">üîä Wycisz d≈∫wiƒôki</button>
        </div>
        <div class="host-panel-section">
            <div class="host-panel-section-title">Pok√≥j</div>
            <button class="host-action-btn danger" id="leaveGameBtn">üö™ Opu≈õƒá grƒô</button>
        </div>
        <div class="room-info-small">Kod pokoju: <span id="roomCodeSmall">----</span></div>
    </div>

    <!-- QRCode Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    
    <!-- Firebase -->
    <script type="module">
        // =============================================
        // FIREBASE CONFIG
        // =============================================
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { 
            getDatabase, ref, set, get, onValue, off, update, remove, onDisconnect, serverTimestamp 
        } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyCQwMpiRgAIXs7g6el_35HepBqOcm6gQVU",
            authDomain: "tm-timer-nw.firebaseapp.com",
            databaseURL: "https://tm-timer-nw-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "tm-timer-nw",
            storageBucket: "tm-timer-nw.firebasestorage.app",
            messagingSenderId: "425133932279",
            appId: "1:425133932279:web:c631018437f5dcdf115df2"
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        
        // =============================================
        // CONSTANTS
        // =============================================
        const COLORS = ['blue', 'red', 'green', 'yellow', 'black'];
        const COLOR_HEX = { red: '#f43f5e', blue: '#3b82f6', green: '#22c55e', yellow: '#facc15', black: '#6b7280' };
        
        const POLISH_ORDINALS = {
            1: 'pierwsze', 2: 'drugie', 3: 'trzecie', 4: 'czwarte', 5: 'piƒÖte',
            6: 'sz√≥ste', 7: 'si√≥dme', 8: '√≥sme', 9: 'dziewiƒÖte', 10: 'dziesiƒÖte',
            11: 'jedenaste', 12: 'dwunaste', 13: 'trzynaste', 14: 'czternaste', 15: 'piƒôtnaste',
            16: 'szesnaste', 17: 'siedemnaste', 18: 'osiemnaste', 19: 'dziewiƒôtnaste', 20: 'dwudzieste'
        };
        
        // =============================================
        // STATE
        // =============================================
        let state = {
            roomId: null,
            playerId: null,
            playerName: '',
            playerColor: 'blue',
            isHost: false,
            isMuted: false,
            turnDuration: 45,
            players: {},
            gameState: null,
            localTimerInterval: null,
            gameTimerInterval: null,
            audioContext: null,
            holdTimeout: null,
            holdProgress: 0,
            lastAnnouncedTurnTime: 0,
            lastAnnouncedGeneration: 0,
            warningPlayed: false,
            timeUpPlayed: false
        };
        
        let unsubscribers = [];
        
        // =============================================
        // TTS MODULE - NAPRAWIONY DLA ANDROID + iOS
        // =============================================
        const TTS = {
            isUnlocked: false,
            platform: 'desktop',
            speakQueue: [],
            isSpeaking: false,
            retryCount: 0,
            maxRetries: 3,
            
            // Detect platform
            detectPlatform() {
                const ua = navigator.userAgent.toLowerCase();
                if (/iphone|ipad|ipod/.test(ua)) {
                    this.platform = 'ios';
                } else if (/android/.test(ua)) {
                    this.platform = 'android';
                } else {
                    this.platform = 'desktop';
                }
                console.log('[TTS] Platform detected:', this.platform);
                return this.platform;
            },
            
            // Initialize
            init() {
                if (!('speechSynthesis' in window)) {
                    console.warn('[TTS] Speech Synthesis NOT supported');
                    return false;
                }
                
                this.detectPlatform();
                console.log('[TTS] Initializing for platform:', this.platform);
                
                // Preload voices
                this.loadVoices();
                
                // Voice changed event
                if (speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = () => {
                        console.log('[TTS] Voices changed event');
                        this.loadVoices();
                    };
                }
                
                // Periodic voice loading for Android
                if (this.platform === 'android') {
                    setTimeout(() => this.loadVoices(), 500);
                    setTimeout(() => this.loadVoices(), 1000);
                    setTimeout(() => this.loadVoices(), 2000);
                }
                
                return true;
            },
            
            // Load voices (for logging only - we won't use them on Android)
            loadVoices() {
                const voices = speechSynthesis.getVoices();
                console.log('[TTS] Voices available:', voices.length);
                
                if (voices.length > 0) {
                    const plVoices = voices.filter(v => v.lang && v.lang.startsWith('pl'));
                    console.log('[TTS] Polish voices:', plVoices.map(v => `${v.name} (${v.lang})`));
                }
            },
            
            // Unlock TTS - MUST be called from user gesture
            async unlock() {
                if (this.isUnlocked) {
                    console.log('[TTS] Already unlocked');
                    return true;
                }
                
                console.log('[TTS] Attempting unlock on', this.platform);
                
                return new Promise((resolve) => {
                    try {
                        // Cancel any pending
                        speechSynthesis.cancel();
                        
                        // Create silent utterance
                        const utterance = new SpeechSynthesisUtterance('');
                        utterance.volume = 0.01;
                        utterance.rate = 10;
                        utterance.lang = 'pl-PL';
                        // CRITICAL: Don't set voice - let system choose
                        utterance.voice = null;
                        
                        utterance.onend = () => {
                            this.isUnlocked = true;
                            console.log('[TTS] ‚úì Unlocked via onend');
                            resolve(true);
                        };
                        
                        utterance.onerror = (e) => {
                            console.log('[TTS] Unlock error (OK):', e.error);
                            this.isUnlocked = true;
                            resolve(true);
                        };
                        
                        speechSynthesis.speak(utterance);
                        
                        // Timeout fallback
                        setTimeout(() => {
                            this.isUnlocked = true;
                            console.log('[TTS] ‚úì Unlocked via timeout');
                            resolve(true);
                        }, 500);
                        
                    } catch (e) {
                        console.error('[TTS] Unlock exception:', e);
                        this.isUnlocked = true;
                        resolve(true);
                    }
                });
            },
            
            // Main speak function - ANDROID FIX
            speak(text) {
                if (!state.isHost) {
                    console.log('[TTS] Not host, skip:', text);
                    return;
                }
                
                if (state.isMuted) {
                    console.log('[TTS] Muted, skip:', text);
                    return;
                }
                
                if (!('speechSynthesis' in window)) {
                    console.log('[TTS] No support');
                    return;
                }
                
                console.log('[TTS] ‚ñ∂‚ñ∂‚ñ∂ SPEAK:', text, '| Platform:', this.platform, '| Unlocked:', this.isUnlocked);
                
                // Add to queue
                this.speakQueue.push(text);
                
                // Process queue
                if (!this.isSpeaking) {
                    this.processQueue();
                }
            },
            
            // Process speech queue
            processQueue() {
                if (this.speakQueue.length === 0) {
                    this.isSpeaking = false;
                    return;
                }
                
                this.isSpeaking = true;
                const text = this.speakQueue.shift();
                
                this.doSpeak(text);
            },
            
            // Actual speech execution
            doSpeak(text) {
                console.log('[TTS] doSpeak:', text);
                
                // CRITICAL: Always cancel first
                speechSynthesis.cancel();
                
                // Delay after cancel - LONGER for Android
                const delay = this.platform === 'android' ? 250 : 
                              this.platform === 'ios' ? 100 : 50;
                
                setTimeout(() => {
                    try {
                        // Check if speechSynthesis is stuck (Android issue)
                        if (speechSynthesis.speaking || speechSynthesis.pending) {
                            console.log('[TTS] SpeechSynthesis busy, forcing cancel');
                            speechSynthesis.cancel();
                        }
                        
                        const utterance = new SpeechSynthesisUtterance(text);
                        
                        // =============================================
                        // ANDROID FIX: NEVER set voice object!
                        // Just set lang and let system handle it
                        // =============================================
                        utterance.voice = null;  // CRITICAL for Android
                        utterance.lang = 'pl-PL';
                        utterance.rate = 1.0;
                        utterance.pitch = 1.0;
                        utterance.volume = 1.0;
                        
                        console.log('[TTS] Utterance created:', {
                            text: text,
                            lang: utterance.lang,
                            voice: utterance.voice,
                            platform: this.platform
                        });
                        
                        utterance.onstart = () => {
                            console.log('[TTS] ‚úì Started:', text);
                            this.retryCount = 0;
                        };
                        
                        utterance.onend = () => {
                            console.log('[TTS] ‚úì Ended:', text);
                            this.isSpeaking = false;
                            this.retryCount = 0;
                            // Process next in queue
                            setTimeout(() => this.processQueue(), 100);
                        };
                        
                        utterance.onerror = (e) => {
                            console.error('[TTS] ‚úó Error:', e.error, 'for:', text);
                            
                            // Retry logic for Android
                            if (e.error !== 'interrupted' && e.error !== 'canceled') {
                                if (this.retryCount < this.maxRetries) {
                                    this.retryCount++;
                                    console.log('[TTS] Retry #' + this.retryCount);
                                    setTimeout(() => this.doSpeak(text), 300);
                                    return;
                                }
                            }
                            
                            this.isSpeaking = false;
                            this.retryCount = 0;
                            setTimeout(() => this.processQueue(), 100);
                        };
                        
                        // Resume if paused (Chrome desktop bug)
                        if (speechSynthesis.paused) {
                            console.log('[TTS] Resuming paused synthesis');
                            speechSynthesis.resume();
                        }
                        
                        // Speak!
                        speechSynthesis.speak(utterance);
                        
                        // Android workaround: Check if actually started
                        if (this.platform === 'android') {
                            setTimeout(() => {
                                if (!speechSynthesis.speaking && !speechSynthesis.pending) {
                                    console.log('[TTS] Android: Speech didn\'t start, retrying...');
                                    if (this.retryCount < this.maxRetries) {
                                        this.retryCount++;
                                        this.doSpeak(text);
                                    }
                                }
                            }, 500);
                        }
                        
                    } catch (e) {
                        console.error('[TTS] Exception:', e);
                        this.isSpeaking = false;
                        setTimeout(() => this.processQueue(), 100);
                    }
                }, delay);
            },
            
            // Stop all speech
            stop() {
                console.log('[TTS] Stopping all');
                this.speakQueue = [];
                this.isSpeaking = false;
                this.retryCount = 0;
                speechSynthesis.cancel();
            }
        };
        
        // =============================================
        // DOM ELEMENTS
        // =============================================
        const $ = id => document.getElementById(id);
        const el = {
            connectionStatus: $('connectionStatus'),
            lobbyScreen: $('lobbyScreen'),
            waitingScreen: $('waitingScreen'),
            gameScreen: $('gameScreen'),
            nameModal: $('nameModal'),
            createRoomBtn: $('createRoomBtn'),
            showJoinBtn: $('showJoinBtn'),
            joinForm: $('joinForm'),
            joinCodeInput: $('joinCodeInput'),
            joinRoomBtn: $('joinRoomBtn'),
            playerNameInput: $('playerNameInput'),
            colorPicker: $('colorPicker'),
            confirmNameBtn: $('confirmNameBtn'),
            roomCodeDisplay: $('roomCodeDisplay'),
            qrContainer: $('qrContainer'),
            timeSettingMini: $('timeSettingMini'),
            timeValueMini: $('timeValueMini'),
            timeUpMini: $('timeUpMini'),
            timeDownMini: $('timeDownMini'),
            waitingPlayersList: $('waitingPlayersList'),
            startGameBtn: $('startGameBtn'),
            leaveRoomBtn: $('leaveRoomBtn'),
            genNumber: $('genNumber'),
            gameTimer: $('gameTimer'),
            playersStrip: $('playersStrip'),
            currentPlayerName: $('currentPlayerName'),
            currentPlayerLabel: $('currentPlayerLabel'),
            timerText: $('timerText'),
            timerProgress: $('timerProgress'),
            passBtn: $('passBtn'),
            passGenBtn: $('passGenBtn'),
            adminTimeBtn: $('adminTimeBtn'),
            adminOverlay: $('adminOverlay'),
            overlayTitle: $('overlayTitle'),
            overlayText: $('overlayText'),
            resumeBtn: $('resumeBtn'),
            menuBtn: $('menuBtn'),
            hostPanel: $('hostPanel'),
            hostPanelBackdrop: $('hostPanelBackdrop'),
            closePanelBtn: $('closePanelBtn'),
            hostOnlySection: $('hostOnlySection'),
            hostSoundSection: $('hostSoundSection'),
            nextGenBtn: $('nextGenBtn'),
            forceNextBtn: $('forceNextBtn'),
            hostAdminBtn: $('hostAdminBtn'),
            muteBtn: $('muteBtn'),
            leaveGameBtn: $('leaveGameBtn'),
            roomCodeSmall: $('roomCodeSmall')
        };
        
        // =============================================
        // UTILITY FUNCTIONS
        // =============================================
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            let code = '';
            for (let i = 0; i < 4; i++) code += chars[Math.floor(Math.random() * chars.length)];
            return code;
        }
        
        function generatePlayerId() {
            return 'p_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }
        
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            $(screenId).classList.add('active');
        }
        
        function formatTime(seconds) {
            const abs = Math.abs(Math.ceil(seconds));
            const mins = Math.floor(abs / 60);
            const secs = abs % 60;
            const sign = seconds < 0 ? '-' : '';
            return mins > 0 ? `${sign}${mins}:${secs.toString().padStart(2, '0')}` : `${sign}${secs}`;
        }
        
        function formatGameTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hrs > 0) return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function getPolishOrdinal(num) {
            if (POLISH_ORDINALS[num]) return POLISH_ORDINALS[num];
            return num.toString();
        }
        
        // =============================================
        // AUDIO - SOUND EFFECTS
        // =============================================
        async function initAudio() {
            console.log('[AUDIO] Initializing...');
            
            // AudioContext
            if (!state.audioContext) {
                try {
                    state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('[AUDIO] AudioContext created');
                } catch (e) {
                    console.error('[AUDIO] AudioContext failed:', e);
                }
            }
            
            if (state.audioContext?.state === 'suspended') {
                await state.audioContext.resume();
                console.log('[AUDIO] AudioContext resumed');
            }
            
            // TTS unlock
            await TTS.unlock();
            
            console.log('[AUDIO] Init complete');
        }
        
        function playBeep(freq = 800, dur = 150, type = 'sine', volume = 0.3) {
            if (!state.isHost || !state.audioContext || state.isMuted) return;
            
            try {
                if (state.audioContext.state === 'suspended') {
                    state.audioContext.resume();
                }
                
                const osc = state.audioContext.createOscillator();
                const gain = state.audioContext.createGain();
                osc.connect(gain);
                gain.connect(state.audioContext.destination);
                osc.frequency.value = freq;
                osc.type = type;
                gain.gain.setValueAtTime(volume, state.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + dur / 1000);
                osc.start(state.audioContext.currentTime);
                osc.stop(state.audioContext.currentTime + dur / 1000);
            } catch (e) {
                console.warn('[AUDIO] Beep error:', e);
            }
        }
        
        function playTurnStart() {
            playBeep(600, 100);
            setTimeout(() => playBeep(800, 150), 120);
        }
        
        function playWarning() {
            playBeep(880, 150, 'sine', 0.4);
        }
        
        function playTimeUp() {
            playBeep(300, 300, 'sawtooth', 0.5);
            setTimeout(() => playBeep(250, 400, 'sawtooth', 0.5), 350);
        }
        
        // =============================================
        // WAKE LOCK
        // =============================================
        let wakeLock = null;
        
        async function requestWakeLock() {
            if (!('wakeLock' in navigator)) return;
            
            try {
                if (wakeLock) {
                    await wakeLock.release();
                }
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('[WAKE] Lock acquired');
            } catch (err) {
                console.log('[WAKE] Error:', err.message);
            }
        }
        
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
                await requestWakeLock();
                if (state.audioContext?.state === 'suspended') {
                    state.audioContext.resume();
                }
            }
        });
        
        // =============================================
        // SESSION STORAGE
        // =============================================
        function saveSession() {
            localStorage.setItem('marsTimer_session', JSON.stringify({
                roomId: state.roomId,
                playerId: state.playerId,
                playerName: state.playerName,
                playerColor: state.playerColor,
                isHost: state.isHost
            }));
        }
        
        function loadSession() {
            try {
                const saved = localStorage.getItem('marsTimer_session');
                return saved ? JSON.parse(saved) : null;
            } catch(e) {
                return null;
            }
        }
        
        function clearSession() {
            localStorage.removeItem('marsTimer_session');
        }
        
        // =============================================
        // QR CODE
        // =============================================
        function generateQR(code) {
            el.qrContainer.innerHTML = '';
            const url = window.location.href.split('?')[0] + '?room=' + code;
            if (typeof QRCode !== 'undefined') {
                QRCode.toCanvas(url, { width: 120, margin: 1 }, (err, canvas) => {
                    if (!err) el.qrContainer.appendChild(canvas);
                });
            }
        }
        
        // =============================================
        // FIREBASE: ROOM MANAGEMENT
        // =============================================
        async function createRoom() {
            await initAudio();
            
            const roomCode = generateRoomCode();
            state.roomId = roomCode;
            state.playerId = generatePlayerId();
            state.isHost = true;
            
            await set(ref(db, `rooms/${roomCode}`), {
                host: state.playerId,
                state: 'waiting',
                turnDuration: state.turnDuration,
                createdAt: serverTimestamp()
            });
            
            showNameModal();
        }
        
        async function joinRoom(code) {
            await initAudio();
            
            const roomCode = code.toUpperCase();
            const snapshot = await get(ref(db, `rooms/${roomCode}`));
            
            if (!snapshot.exists()) {
                alert('Nie znaleziono pokoju o tym kodzie!');
                return false;
            }
            
            const roomData = snapshot.val();
            if (roomData.state !== 'waiting') {
                alert('Gra ju≈º siƒô rozpoczƒô≈Ça!');
                return false;
            }
            
            state.roomId = roomCode;
            state.playerId = generatePlayerId();
            state.isHost = false;
            state.turnDuration = roomData.turnDuration || 45;
            
            showNameModal();
            return true;
        }
        
        function showNameModal() {
            el.nameModal.classList.add('active');
            el.playerNameInput.focus();
        }
        
        async function confirmPlayer() {
            const name = el.playerNameInput.value.trim();
            if (!name) {
                alert('Wpisz swoje imiƒô!');
                return;
            }
            
            await initAudio();
            
            state.playerName = name;
            
            const playersRef = ref(db, `rooms/${state.roomId}/players`);
            const snapshot = await get(playersRef);
            const existingPlayers = snapshot.exists() ? Object.keys(snapshot.val()).length : 0;
            
            const playerRef = ref(db, `rooms/${state.roomId}/players/${state.playerId}`);
            await set(playerRef, {
                name: state.playerName,
                color: state.playerColor,
                passedGen: false,
                online: true,
                order: existingPlayers,
                isHost: state.isHost
            });
            
            onDisconnect(playerRef).update({ online: false });
            
            el.nameModal.classList.remove('active');
            saveSession();
            
            if (state.isHost) {
                document.body.classList.add('is-host');
                el.hostOnlySection.style.display = 'block';
                el.hostSoundSection.style.display = 'block';
                el.timeSettingMini.style.display = 'flex';
            }
            
            enterWaitingRoom();
        }
        
        function enterWaitingRoom() {
            showScreen('waitingScreen');
            el.roomCodeDisplay.textContent = state.roomId;
            el.roomCodeSmall.textContent = state.roomId;
            el.timeValueMini.textContent = state.turnDuration;
            generateQR(state.roomId);
            
            const roomRef = ref(db, `rooms/${state.roomId}`);
            const unsubRoom = onValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    alert('Pok√≥j zosta≈Ç zamkniƒôty');
                    leaveRoom();
                    return;
                }
                
                const data = snapshot.val();
                state.players = data.players || {};
                state.turnDuration = data.turnDuration || 45;
                el.timeValueMini.textContent = state.turnDuration;
                
                updateWaitingPlayersList();
                updateStartButton();
                
                if (data.state === 'playing') {
                    startGameListener();
                }
            });
            unsubscribers.push(() => off(roomRef));
            
            if (state.isHost) {
                el.startGameBtn.textContent = 'Rozpocznij grƒô';
            } else {
                el.startGameBtn.textContent = 'Czekam na hosta...';
                el.startGameBtn.disabled = true;
            }
        }
        
        function updateWaitingPlayersList() {
            const players = Object.entries(state.players).sort((a, b) => a[1].order - b[1].order);
            el.waitingPlayersList.innerHTML = players.map(([id, p]) => `
                <div class="player-waiting-item ${!p.online ? 'offline' : ''}">
                    <div class="player-waiting-color" style="background: ${COLOR_HEX[p.color]}"></div>
                    <div class="player-waiting-name">${p.name}</div>
                    ${p.isHost ? '<div class="player-waiting-host">Host</div>' : ''}
                    ${id === state.playerId ? '<div class="player-waiting-you">Ty</div>' : ''}
                </div>
            `).join('');
        }
        
        function updateStartButton() {
            if (!state.isHost) return;
            const onlinePlayers = Object.values(state.players).filter(p => p.online).length;
            el.startGameBtn.disabled = onlinePlayers < 2;
            el.startGameBtn.textContent = onlinePlayers < 2 ? 'Minimum 2 graczy' : 'Rozpocznij grƒô';
        }
        
        async function updateTurnDuration(delta) {
            if (!state.isHost) return;
            state.turnDuration = Math.max(15, Math.min(180, state.turnDuration + delta));
            await update(ref(db, `rooms/${state.roomId}`), { turnDuration: state.turnDuration });
        }
        
        // =============================================
        // START GAME - OG≈ÅOSZENIE PIERWSZEGO GRACZA
        // =============================================
        async function startGame() {
            if (!state.isHost) return;
            
            await initAudio();
            
            const players = Object.entries(state.players)
                .filter(([id, p]) => p.online)
                .sort((a, b) => a[1].order - b[1].order);
            const playerIds = players.map(([id]) => id);
            
            const turnStartTime = Date.now();
            
            await update(ref(db, `rooms/${state.roomId}`), {
                state: 'playing',
                generation: 1,
                currentPlayerIndex: 0,
                startPlayerIndex: 0,
                playerOrder: playerIds,
                turnStartTime: turnStartTime,
                turnDuration: state.turnDuration,
                isPaused: false,
                gameStartTime: Date.now()
            });
            
            // Mark as announced
            state.lastAnnouncedTurnTime = turnStartTime;
            state.lastAnnouncedGeneration = 1;
            
            // ANNOUNCE FIRST PLAYER IMMEDIATELY
            const firstPlayer = players[0][1];
            console.log('[GAME] ‚ñ∂‚ñ∂‚ñ∂ Starting game! First player:', firstPlayer.name);
            
            playTurnStart();
            TTS.speak(firstPlayer.name);
        }
        
        function startGameListener() {
            showScreen('gameScreen');
            requestWakeLock();
            
            if (state.localTimerInterval) clearInterval(state.localTimerInterval);
            if (state.gameTimerInterval) clearInterval(state.gameTimerInterval);
            
            state.warningPlayed = false;
            state.timeUpPlayed = false;
            
            const roomRef = ref(db, `rooms/${state.roomId}`);
            const unsubGame = onValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    leaveRoom();
                    return;
                }
                
                const data = snapshot.val();
                state.gameState = data;
                state.players = data.players || {};
                
                if (data.state === 'playing') {
                    updateGameUI(data);
                    
                    // Turn change detection via turnStartTime
                    if (state.isHost && data.turnStartTime && !data.isPaused) {
                        if (data.turnStartTime !== state.lastAnnouncedTurnTime) {
                            const playerOrder = data.playerOrder || [];
                            const currentPlayerId = playerOrder[data.currentPlayerIndex];
                            const currentPlayer = data.players?.[currentPlayerId];
                            
                            if (currentPlayer) {
                                console.log('[TURN] ‚ñ∂‚ñ∂‚ñ∂ New turn! Player:', currentPlayer.name);
                                
                                state.warningPlayed = false;
                                state.timeUpPlayed = false;
                                
                                setTimeout(() => {
                                    playTurnStart();
                                    TTS.speak(currentPlayer.name);
                                }, 150);
                            }
                            
                            state.lastAnnouncedTurnTime = data.turnStartTime;
                        }
                        
                        if (data.generation !== state.lastAnnouncedGeneration) {
                            state.lastAnnouncedGeneration = data.generation;
                        }
                    }
                    
                } else if (data.state === 'waiting') {
                    enterWaitingRoom();
                }
            });
            unsubscribers.push(() => off(roomRef));
            
            // Timer loop
            state.localTimerInterval = setInterval(() => {
                if (!state.gameState || state.gameState.isPaused) return;
                
                const elapsed = (Date.now() - state.gameState.turnStartTime) / 1000;
                const remaining = state.gameState.turnDuration - elapsed;
                
                updateTimerDisplay(remaining);
                
                if (state.isHost && !state.isMuted) {
                    if (remaining <= 5.1 && remaining > 4.5 && !state.warningPlayed) {
                        playWarning();
                        state.warningPlayed = true;
                    }
                    
                    if (remaining <= 0.1 && remaining > -0.5 && !state.timeUpPlayed) {
                        playTimeUp();
                        state.timeUpPlayed = true;
                    }
                }
            }, 50);
            
            // Game timer
            state.gameTimerInterval = setInterval(() => {
                if (!state.gameState?.gameStartTime) return;
                const elapsed = Math.floor((Date.now() - state.gameState.gameStartTime) / 1000);
                el.gameTimer.textContent = formatGameTime(elapsed);
            }, 1000);
        }
        
        function updateTimerDisplay(remaining) {
            el.timerText.textContent = formatTime(remaining);
            
            const progress = Math.min(1, Math.max(0, (state.gameState.turnDuration - remaining) / state.gameState.turnDuration));
            const circumference = 2 * Math.PI * 130;
            el.timerProgress.style.strokeDashoffset = circumference * (1 - progress);
            
            el.timerText.classList.toggle('overtime', remaining < 0);
            el.timerText.classList.toggle('warning', remaining <= 5 && remaining > 0);
            el.timerProgress.classList.toggle('overtime', remaining < 0);
        }
        
        function updateGameUI(data) {
            el.genNumber.textContent = data.generation || 1;
            
            const playerOrder = data.playerOrder || [];
            const currentPlayerId = playerOrder[data.currentPlayerIndex];
            const currentPlayer = data.players?.[currentPlayerId];
            
            if (currentPlayer) {
                el.currentPlayerName.textContent = currentPlayer.name;
                el.currentPlayerName.style.color = COLOR_HEX[currentPlayer.color];
                
                const isMyTurn = currentPlayerId === state.playerId;
                el.currentPlayerLabel.textContent = isMyTurn ? 'Twoja tura!' : 'Tura gracza';
                
                el.passBtn.disabled = !isMyTurn || data.isPaused;
                el.passGenBtn.disabled = !isMyTurn || data.isPaused;
                
                const timerGradient = document.querySelector('#timerGradient');
                if (timerGradient) {
                    timerGradient.innerHTML = `<stop offset="0%" style="stop-color:${COLOR_HEX[currentPlayer.color]}"/><stop offset="100%" style="stop-color:${COLOR_HEX[currentPlayer.color]}"/>`;
                }
                el.passBtn.style.background = `linear-gradient(135deg, ${COLOR_HEX[currentPlayer.color]}, ${COLOR_HEX[currentPlayer.color]})`;
                el.passBtn.style.boxShadow = `0 8px 32px ${COLOR_HEX[currentPlayer.color]}66`;
            }
            
            // Players strip
            const startIndex = data.startPlayerIndex || 0;
            const orderedPlayers = [];
            for (let i = 0; i < playerOrder.length; i++) {
                const idx = (startIndex + i) % playerOrder.length;
                const pid = playerOrder[idx];
                const p = data.players?.[pid];
                if (p) orderedPlayers.push({ id: pid, ...p, originalIndex: idx });
            }
            
            el.playersStrip.innerHTML = orderedPlayers.map(p => {
                let statusClass = '';
                let statusText = '';
                if (p.passedGen) { statusClass = 'passed-gen'; statusText = 'GEN'; }
                else if (p.id === currentPlayerId) { statusClass = 'active'; }
                if (!p.online) statusClass += ' offline';
                
                return `<div class="player-chip ${statusClass}">
                    <div class="player-chip-dot" style="background: ${COLOR_HEX[p.color]}"></div>
                    <span>${p.name}</span>
                    ${statusText ? `<span class="player-chip-status">${statusText}</span>` : ''}
                </div>`;
            }).join('');
            
            // Admin overlay
            if (data.isPaused) {
                el.adminOverlay.classList.add('active');
                el.overlayTitle.textContent = data.overlayTitle || 'Admin Time';
                el.overlayText.textContent = data.overlayText || 'Gra wstrzymana';
                el.resumeBtn.textContent = data.overlayButton || 'Wzn√≥w grƒô';
            } else {
                el.adminOverlay.classList.remove('active');
            }
            
            const allPassed = playerOrder.every(pid => data.players?.[pid]?.passedGen);
            el.nextGenBtn.style.display = allPassed && state.isHost ? 'block' : 'none';
            el.adminTimeBtn.classList.toggle('active', data.isPaused);
        }
        
        // =============================================
        // GAME ACTIONS
        // =============================================
        
        // Regular PASS
        async function pass() {
            if (!state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            const currentPlayerId = playerOrder[state.gameState.currentPlayerIndex];
            
            if (currentPlayerId !== state.playerId) return;
            
            let nextIndex = state.gameState.currentPlayerIndex;
            let attempts = 0;
            do {
                nextIndex = (nextIndex + 1) % playerOrder.length;
                attempts++;
            } while (state.players[playerOrder[nextIndex]]?.passedGen && attempts < playerOrder.length);
            
            const newTurnTime = Date.now();
            
            console.log('[PASS] From', state.gameState.currentPlayerIndex, 'to', nextIndex);
            
            await update(ref(db, `rooms/${state.roomId}`), {
                currentPlayerIndex: nextIndex,
                turnStartTime: newTurnTime
            });
        }
        
        // PASS GEN - z prawid≈ÇowƒÖ logikƒÖ komunikat√≥w
        async function passGen() {
            if (!state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            const currentPlayerId = playerOrder[state.gameState.currentPlayerIndex];
            
            if (currentPlayerId !== state.playerId) return;
            
            // Mark as passed
            await update(ref(db, `rooms/${state.roomId}/players/${state.playerId}`), {
                passedGen: true
            });
            
            // Count active players AFTER this pass
            const updatedPlayers = { ...state.players };
            updatedPlayers[state.playerId].passedGen = true;
            
            const activePlayersRemaining = playerOrder.filter(pid => !updatedPlayers[pid]?.passedGen);
            const isLastPlayer = activePlayersRemaining.length === 0;
            
            console.log('[PASS GEN] Player:', state.playerName, '| Active remaining:', activePlayersRemaining.length, '| IsLast:', isLastPlayer);
            
            if (isLastPlayer) {
                // =============================================
                // SCENARIO 2: OSTATNI GRACZ - "Koniec pokolenia X"
                // =============================================
                const genNum = state.gameState.generation;
                const ordinal = getPolishOrdinal(genNum);
                
                console.log('[PASS GEN] ‚ñ∂‚ñ∂‚ñ∂ Last player! Announcing: Koniec pokolenia', ordinal);
                
                if (state.isHost) {
                    TTS.speak(`Koniec pokolenia ${ordinal}`);
                }
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    isPaused: true,
                    overlayTitle: 'Koniec pokolenia ' + genNum,
                    overlayText: 'Wszyscy spasowali',
                    overlayButton: 'üöÄ Nastƒôpne Pokolenie'
                });
                
            } else {
                // =============================================
                // SCENARIO 1: SƒÑ JESZCZE INNI GRACZE - "{Imiƒô} spasowa≈Ç"
                // =============================================
                let nextIndex = state.gameState.currentPlayerIndex;
                let attempts = 0;
                do {
                    nextIndex = (nextIndex + 1) % playerOrder.length;
                    attempts++;
                } while (updatedPlayers[playerOrder[nextIndex]]?.passedGen && attempts < playerOrder.length);
                
                const nextPlayer = state.players[playerOrder[nextIndex]];
                
                console.log('[PASS GEN] ‚ñ∂‚ñ∂‚ñ∂ Not last! Announcing:', state.playerName, 'spasowa≈Ç, next:', nextPlayer?.name);
                
                if (state.isHost) {
                    TTS.speak(`${state.playerName} spasowa≈Ç`);
                }
                
                // Delay turn change for speech
                const newTurnTime = Date.now() + 2000;
                state.lastAnnouncedTurnTime = newTurnTime;
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    currentPlayerIndex: nextIndex,
                    turnStartTime: newTurnTime
                });
            }
        }
        
        // NEXT GENERATION
        async function nextGeneration() {
            if (!state.isHost || !state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            const newGeneration = state.gameState.generation + 1;
            const newStartIndex = (state.gameState.startPlayerIndex + 1) % playerOrder.length;
            
            const firstPlayerId = playerOrder[newStartIndex];
            const firstPlayer = state.players[firstPlayerId];
            
            const ordinal = getPolishOrdinal(newGeneration);
            
            console.log('[NEXT GEN] ‚ñ∂‚ñ∂‚ñ∂ Generation:', newGeneration, '| First player:', firstPlayer?.name);
            
            TTS.speak(`Pokolenie ${ordinal}`);
            
            const newTurnTime = Date.now() + 2500;
            state.lastAnnouncedTurnTime = newTurnTime;
            state.lastAnnouncedGeneration = newGeneration;
            
            const updates = {
                generation: newGeneration,
                currentPlayerIndex: newStartIndex,
                startPlayerIndex: newStartIndex,
                turnStartTime: newTurnTime,
                isPaused: false
            };
            
            playerOrder.forEach(pid => {
                updates[`players/${pid}/passedGen`] = false;
            });
            
            await update(ref(db, `rooms/${state.roomId}`), updates);
            
            setTimeout(() => {
                playTurnStart();
                TTS.speak(firstPlayer?.name);
            }, 2500);
        }
        
        // ADMIN TIME
        async function toggleAdminTime() {
            if (!state.isHost || !state.gameState) return;
            
            const isPaused = !state.gameState.isPaused;
            
            if (isPaused) {
                console.log('[ADMIN] ‚ñ∂‚ñ∂‚ñ∂ Pausing - Admin time');
                TTS.speak('Admin time');
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    isPaused: true,
                    pausedAt: Date.now(),
                    overlayTitle: 'Admin Time',
                    overlayText: 'Gra wstrzymana',
                    overlayButton: 'Wzn√≥w grƒô'
                });
            } else {
                console.log('[ADMIN] Resuming');
                const pauseDuration = Date.now() - (state.gameState.pausedAt || Date.now());
                const newTurnTime = state.gameState.turnStartTime + pauseDuration;
                
                state.lastAnnouncedTurnTime = newTurnTime;
                
                await update(ref(db, `rooms/${state.roomId}`), {
                    isPaused: false,
                    turnStartTime: newTurnTime
                });
            }
        }
        
        // FORCE NEXT TURN
        async function forceNextTurn() {
            if (!state.isHost || !state.gameState) return;
            
            const playerOrder = state.gameState.playerOrder;
            let nextIndex = state.gameState.currentPlayerIndex;
            let attempts = 0;
            
            do {
                nextIndex = (nextIndex + 1) % playerOrder.length;
                attempts++;
            } while (state.players[playerOrder[nextIndex]]?.passedGen && attempts < playerOrder.length);
            
            console.log('[FORCE] Next turn to index:', nextIndex);
            
            await update(ref(db, `rooms/${state.roomId}`), {
                currentPlayerIndex: nextIndex,
                turnStartTime: Date.now()
            });
        }
        
        async function leaveRoom() {
            unsubscribers.forEach(unsub => unsub());
            unsubscribers = [];
            
            if (state.localTimerInterval) clearInterval(state.localTimerInterval);
            if (state.gameTimerInterval) clearInterval(state.gameTimerInterval);
            
            TTS.stop();
            
            if (state.roomId && state.playerId) {
                try {
                    if (state.isHost) {
                        await remove(ref(db, `rooms/${state.roomId}`));
                    } else {
                        await remove(ref(db, `rooms/${state.roomId}/players/${state.playerId}`));
                    }
                } catch(e) {}
            }
            
            state.roomId = null;
            state.playerId = null;
            state.isHost = false;
            state.gameState = null;
            state.players = {};
            state.lastAnnouncedTurnTime = 0;
            state.lastAnnouncedGeneration = 0;
            state.warningPlayed = false;
            state.timeUpPlayed = false;
            
            clearSession();
            document.body.classList.remove('is-host');
            el.hostOnlySection.style.display = 'none';
            el.hostSoundSection.style.display = 'none';
            el.timeSettingMini.style.display = 'none';
            showScreen('lobbyScreen');
            el.joinForm.classList.remove('active');
        }
        
        // =============================================
        // HOLD FOR PASS GEN
        // =============================================
        function startHold() {
            if (el.passGenBtn.disabled) return;
            state.holdProgress = 0;
            const progressFill = el.passGenBtn.querySelector('.progress-fill');
            state.holdTimeout = setInterval(() => {
                state.holdProgress += 10;
                progressFill.style.width = state.holdProgress + '%';
                if (state.holdProgress >= 100) endHold(true);
            }, 50);
        }
        
        function endHold(confirmed = false) {
            if (state.holdTimeout) {
                clearInterval(state.holdTimeout);
                state.holdTimeout = null;
            }
            el.passGenBtn.querySelector('.progress-fill').style.width = '0%';
            state.holdProgress = 0;
            if (confirmed) passGen();
        }
        
        // =============================================
        // EVENT LISTENERS
        // =============================================
        el.createRoomBtn.addEventListener('click', createRoom);
        
        el.showJoinBtn.addEventListener('click', () => {
            el.joinForm.classList.toggle('active');
            el.joinCodeInput.focus();
        });
        
        el.joinCodeInput.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase().replace(/[^A-Z]/g, '');
        });
        
        el.joinRoomBtn.addEventListener('click', () => {
            if (el.joinCodeInput.value.length === 4) joinRoom(el.joinCodeInput.value);
        });
        
        el.joinCodeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && el.joinCodeInput.value.length === 4) joinRoom(el.joinCodeInput.value);
        });
        
        el.colorPicker.addEventListener('click', (e) => {
            const option = e.target.closest('.color-option');
            if (option) {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                state.playerColor = option.dataset.color;
            }
        });
        
        el.confirmNameBtn.addEventListener('click', confirmPlayer);
        el.playerNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') confirmPlayer();
        });
        
        el.timeUpMini.addEventListener('click', () => updateTurnDuration(5));
        el.timeDownMini.addEventListener('click', () => updateTurnDuration(-5));
        
        el.startGameBtn.addEventListener('click', startGame);
        el.leaveRoomBtn.addEventListener('click', leaveRoom);
        
        el.passBtn.addEventListener('click', pass);
        
        el.passGenBtn.addEventListener('mousedown', startHold);
        el.passGenBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(); }, { passive: false });
        el.passGenBtn.addEventListener('mouseup', () => endHold(false));
        el.passGenBtn.addEventListener('mouseleave', () => endHold(false));
        el.passGenBtn.addEventListener('touchend', () => endHold(false));
        el.passGenBtn.addEventListener('touchcancel', () => endHold(false));
        
        el.adminTimeBtn.addEventListener('click', toggleAdminTime);
        
        el.resumeBtn.addEventListener('click', () => {
            if (state.gameState?.overlayButton?.includes('Pokolenie')) {
                nextGeneration();
            } else {
                toggleAdminTime();
            }
        });
        
        el.menuBtn.addEventListener('click', () => {
            el.hostPanel.classList.add('open');
            el.hostPanelBackdrop.classList.add('open');
        });
        
        el.closePanelBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
        });
        
        el.hostPanelBackdrop.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
        });
        
        el.nextGenBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
            nextGeneration();
        });
        
        el.forceNextBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
            forceNextTurn();
        });
        
        el.hostAdminBtn.addEventListener('click', () => {
            el.hostPanel.classList.remove('open');
            el.hostPanelBackdrop.classList.remove('open');
            toggleAdminTime();
        });
        
        el.muteBtn.addEventListener('click', () => {
            state.isMuted = !state.isMuted;
            el.muteBtn.textContent = state.isMuted ? 'üîá W≈ÇƒÖcz d≈∫wiƒôki' : 'üîä Wycisz d≈∫wiƒôki';
            if (state.isMuted) TTS.stop();
        });
        
        el.leaveGameBtn.addEventListener('click', () => {
            if (confirm(state.isHost ? 'Jako host, opuszczenie gry zamknie pok√≥j dla wszystkich. Kontynuowaƒá?' : 'Czy na pewno chcesz opu≈õciƒá grƒô?')) {
                el.hostPanel.classList.remove('open');
                el.hostPanelBackdrop.classList.remove('open');
                leaveRoom();
            }
        });
        
        // Prevent double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) e.preventDefault();
            lastTouchEnd = now;
        }, false);
        
        // =============================================
        // INITIALIZATION
        // =============================================
        async function init() {
            console.log('[INIT] Mars Timer starting...');
            
            requestWakeLock();
            TTS.init();
            
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');
            
            if (roomCode) {
                el.joinCodeInput.value = roomCode;
                el.joinForm.classList.add('active');
            }
            
            const session = loadSession();
            if (session?.roomId) {
                try {
                    const snapshot = await get(ref(db, `rooms/${session.roomId}`));
                    
                    if (snapshot.exists()) {
                        const roomData = snapshot.val();
                        if (roomData.players?.[session.playerId]) {
                            state.roomId = session.roomId;
                            state.playerId = session.playerId;
                            state.playerName = session.playerName;
                            state.playerColor = session.playerColor;
                            state.isHost = session.isHost;
                            state.turnDuration = roomData.turnDuration || 45;
                            
                            if (state.isHost) {
                                document.body.classList.add('is-host');
                                el.hostOnlySection.style.display = 'block';
                                el.hostSoundSection.style.display = 'block';
                                el.timeSettingMini.style.display = 'flex';
                            }
                            
                            await update(ref(db, `rooms/${state.roomId}/players/${state.playerId}`), { online: true });
                            onDisconnect(ref(db, `rooms/${state.roomId}/players/${state.playerId}`)).update({ online: false });
                            
                            if (roomData.state === 'playing') {
                                state.lastAnnouncedTurnTime = roomData.turnStartTime || 0;
                                state.lastAnnouncedGeneration = roomData.generation || 1;
                                startGameListener();
                            } else {
                                enterWaitingRoom();
                            }
                            return;
                        }
                    }
                } catch(e) {
                    console.log('[INIT] Reconnect failed:', e);
                }
                clearSession();
            }
            
            console.log('[INIT] Ready');
        }
        
        init();
    </script>
</body>
</html>
